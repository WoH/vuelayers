{"version":3,"file":"index.js","sources":["src/component/draw-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/draw-interaction/interaction.vue","src/component/draw-interaction/index.js"],"sourcesContent":["\nimport { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\nimport DrawInteraction from 'ol/interaction/Draw'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapObs } from 'rxjs/operators'\nimport interaction from '../../mixin/interaction'\nimport stylesContainer from '../../mixin/styles-container'\nimport { GEOMETRY_TYPE } from '../../ol-ext/consts'\nimport { initializeFeature } from '../../ol-ext/feature'\nimport { createStyle, defaultEditStyle } from '../../ol-ext/style'\nimport { isCollection, isVectorSource } from '../../ol-ext/util'\nimport observableFromOlEvent from '../../rx-ext/from-ol-event'\nimport { assert, hasInteraction } from '../../util/assert'\nimport { camelCase, mapValues, upperFirst } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nconst transformType = type => upperFirst(camelCase(type))\n\n/**\n * @alias module:draw-interaction/interaction\n * @title vl-interaction-draw\n * @vueProto\n */\nexport default {\n  name: 'vl-interaction-draw',\n  mixins: [interaction, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n  props: {\n    /**\n     * Target source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n     * draw interaction to behave correctly on mouse as well as on touch devices.\n     * @type {number}\n     */\n    clickTolerance: {\n      type: Number,\n      default: 6,\n    },\n    /**\n     * Pixel distance for snapping to the drawing finish.\n     * @type {number}\n     */\n    snapTolerance: {\n      type: Number,\n      default: 12,\n    },\n    /**\n     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n     * @type {string}\n     */\n    type: {\n      type: String,\n      required: true,\n      validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n    },\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * @type {boolean}\n     */\n    stopClick: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The number of points that can be drawn before a polygon ring or line string is finished.\n     * @type {number|undefined}\n     */\n    maxPoints: Number,\n    /**\n     * The number of points that must be drawn before a polygon ring or line string can be finished.\n     * Default is `3` for polygon rings and `2` for line strings.\n     * @type {number|undefined}\n     */\n    minPoints: Number,\n    /**\n     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n     * @type {function|undefined}\n     */\n    finishCondition: Function,\n    /**\n     * Function that is called when a geometry's coordinates are updated.\n     * @type {function|undefined}\n     */\n    geometryFunction: Function,\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string}\n     */\n    geometryName: {\n      type: String,\n      default: 'geometry',\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: noModifierKeys,\n    },\n    /**\n     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n     * freehand mode and takes precedence over any `freehandCondition` option.\n     * @type {boolean}\n     */\n    freehand: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n     * meaning that the Shift key activates freehand drawing.\n     * @type {function|undefined}\n     */\n    freehandCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  methods: {\n    /**\n     * @return {Promise<Draw>}\n     * @protected\n     */\n    async createInteraction () {\n      let sourceIdent = this.makeIdent(this.source)\n      let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n      assert(isVectorSource(source), `Source \"${sourceIdent}\" doesn't exists in the identity map.`)\n      assert(isCollection(source.getFeaturesCollection()),\n        `Source \"${sourceIdent}\" doesn't provide features collection.`)\n\n      return new DrawInteraction({\n        features: source.getFeaturesCollection(),\n        clickTolerance: this.clickTolerance,\n        snapTolerance: this.snapTolerance,\n        type: transformType(this.type),\n        stopClick: this.stopClick,\n        maxPoints: this.maxPoints,\n        minPoints: this.minPoints,\n        finishCondition: this.finishCondition,\n        style: this.createStyleFunc(),\n        geometryFunction: this.geometryFunction,\n        geometryName: this.geometryName,\n        condition: this.condition,\n        freehand: this.freehand,\n        freehandCondition: this.freehandCondition,\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'source',\n      'clickTolerance',\n      'snapTolerance',\n      'type',\n      'stopClick',\n      'maxPoints',\n      'minPoints',\n      'finishCondition',\n      'geometryFunction',\n      'geometryName',\n      'condition',\n      'freehand',\n      'freehandCondition',\n      'wrapX',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const drawEvents = mergeObs(\n    observableFromOlEvent(this.$interaction, 'drawstart')\n      .pipe(\n        mapObs(evt => {\n          initializeFeature(evt.feature)\n          return evt\n        }),\n      ),\n    observableFromOlEvent(this.$interaction, 'drawend'),\n  )\n  this.subscribeTo(drawEvents, evt => {\n    ++this.rev\n    this.$emit(evt.type, evt)\n  })\n}\n","<script>\n  import { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\n  import DrawInteraction from 'ol/interaction/Draw'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapObs } from 'rxjs/operators'\n  import interaction from '../../mixin/interaction'\n  import stylesContainer from '../../mixin/styles-container'\n  import { GEOMETRY_TYPE } from '../../ol-ext/consts'\n  import { initializeFeature } from '../../ol-ext/feature'\n  import { createStyle, defaultEditStyle } from '../../ol-ext/style'\n  import { isCollection, isVectorSource } from '../../ol-ext/util'\n  import observableFromOlEvent from '../../rx-ext/from-ol-event'\n  import { assert, hasInteraction } from '../../util/assert'\n  import { camelCase, mapValues, upperFirst } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  const transformType = type => upperFirst(camelCase(type))\n\n  /**\n   * @alias module:draw-interaction/interaction\n   * @title vl-interaction-draw\n   * @vueProto\n   */\n  export default {\n    name: 'vl-interaction-draw',\n    mixins: [interaction, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n    props: {\n      /**\n       * Target source or collection identifier from IdentityMap.\n       * @type {String}\n       */\n      source: {\n        type: String,\n        required: true,\n      },\n      /**\n       * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n       * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n       * draw interaction to behave correctly on mouse as well as on touch devices.\n       * @type {number}\n       */\n      clickTolerance: {\n        type: Number,\n        default: 6,\n      },\n      /**\n       * Pixel distance for snapping to the drawing finish.\n       * @type {number}\n       */\n      snapTolerance: {\n        type: Number,\n        default: 12,\n      },\n      /**\n       * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n       * @type {string}\n       */\n      type: {\n        type: String,\n        required: true,\n        validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n      },\n      /**\n       * Stop click, singleclick, and doubleclick events from firing during drawing.\n       * @type {boolean}\n       */\n      stopClick: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The number of points that can be drawn before a polygon ring or line string is finished.\n       * @type {number|undefined}\n       */\n      maxPoints: Number,\n      /**\n       * The number of points that must be drawn before a polygon ring or line string can be finished.\n       * Default is `3` for polygon rings and `2` for line strings.\n       * @type {number|undefined}\n       */\n      minPoints: Number,\n      /**\n       * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n       * @type {function|undefined}\n       */\n      finishCondition: Function,\n      /**\n       * Function that is called when a geometry's coordinates are updated.\n       * @type {function|undefined}\n       */\n      geometryFunction: Function,\n      /**\n       * Name of the geometry attribute for newly created features.\n       * @type {string}\n       */\n      geometryName: {\n        type: String,\n        default: 'geometry',\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: noModifierKeys,\n      },\n      /**\n       * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n       * freehand mode and takes precedence over any `freehandCondition` option.\n       * @type {boolean}\n       */\n      freehand: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n       * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n       * meaning that the Shift key activates freehand drawing.\n       * @type {function|undefined}\n       */\n      freehandCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n      /**\n       * Wrap the world horizontally on the sketch overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    methods: {\n      /**\n       * @return {Promise<Draw>}\n       * @protected\n       */\n      async createInteraction () {\n        let sourceIdent = this.makeIdent(this.source)\n        let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n        assert(isVectorSource(source), `Source \"${sourceIdent}\" doesn't exists in the identity map.`)\n        assert(isCollection(source.getFeaturesCollection()),\n          `Source \"${sourceIdent}\" doesn't provide features collection.`)\n\n        return new DrawInteraction({\n          features: source.getFeaturesCollection(),\n          clickTolerance: this.clickTolerance,\n          snapTolerance: this.snapTolerance,\n          type: transformType(this.type),\n          stopClick: this.stopClick,\n          maxPoints: this.maxPoints,\n          minPoints: this.minPoints,\n          finishCondition: this.finishCondition,\n          style: this.createStyleFunc(),\n          geometryFunction: this.geometryFunction,\n          geometryName: this.geometryName,\n          condition: this.condition,\n          freehand: this.freehand,\n          freehandCondition: this.freehandCondition,\n          wrapX: this.wrapX,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'source',\n        'clickTolerance',\n        'snapTolerance',\n        'type',\n        'stopClick',\n        'maxPoints',\n        'minPoints',\n        'finishCondition',\n        'geometryFunction',\n        'geometryName',\n        'condition',\n        'freehand',\n        'freehandCondition',\n        'wrapX',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const drawEvents = mergeObs(\n      observableFromOlEvent(this.$interaction, 'drawstart')\n        .pipe(\n          mapObs(evt => {\n            initializeFeature(evt.feature)\n            return evt\n          }),\n        ),\n      observableFromOlEvent(this.$interaction, 'drawend'),\n    )\n    this.subscribeTo(drawEvents, evt => {\n      ++this.rev\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["transformType","type","upperFirst","camelCase","name","mixins","interaction","stylesContainer","stubVNode","empty","attrs","class","$options","props","source","String","required","clickTolerance","Number","default","snapTolerance","validator","value","Object","values","GEOMETRY_TYPE","includes","stopClick","Boolean","maxPoints","minPoints","finishCondition","Function","geometryFunction","geometryName","condition","noModifierKeys","freehand","freehandCondition","shiftKeyOnly","wrapX","methods","createInteraction","sourceIdent","makeIdent","$identityMap","get","INSTANCE_PROMISE_POOL","assert","isVectorSource","isCollection","getFeaturesCollection","DrawInteraction","features","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","map","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","hasInteraction","drawEvents","mergeObs","observableFromOlEvent","pipe","mapObs","evt","initializeFeature","subscribeTo","rev","$emit","plugin","Vue","options","installed","pick","assign","Interaction","component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,IAAMA,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,IAAI;SAAIC,UAAU,CAACC,SAAS,CAACF,IAAD,CAAV,CAAd;CAA1B;;;;;;;;AAOA,aAAe;EACbG,IAAI,EAAE,qBADO;EAEbC,MAAM,EAAE,CAACC,WAAD,EAAcC,eAAd,CAFK;EAGbC,SAAS,EAAE;IACTC,KAAK,EAAE,KADE;IAETC,KAFS,mBAEA;aACA;QACLC,KAAK,EAAE,KAAKC,QAAL,CAAcR;OADvB;;GANS;EAWbS,KAAK,EAAE;;;;;IAKLC,MAAM,EAAE;MACNb,IAAI,EAAEc,MADA;MAENC,QAAQ,EAAE;KAPP;;;;;;;;IAeLC,cAAc,EAAE;MACdhB,IAAI,EAAEiB,MADQ;MAEdC,OAAO,EAAE;KAjBN;;;;;;IAuBLC,aAAa,EAAE;MACbnB,IAAI,EAAEiB,MADO;MAEbC,OAAO,EAAE;KAzBN;;;;;;IA+BLlB,IAAI,EAAE;MACJA,IAAI,EAAEc,MADF;MAEJC,QAAQ,EAAE,IAFN;MAGJK,SAAS,EAAE,mBAAAC,KAAK;eAAIC,MAAM,CAACC,MAAP,CAAcC,aAAd,EAA6BC,QAA7B,CAAsC1B,aAAa,CAACsB,KAAD,CAAnD,CAAJ;;KAlCb;;;;;;IAwCLK,SAAS,EAAE;MACT1B,IAAI,EAAE2B,OADG;MAETT,OAAO,EAAE;KA1CN;;;;;;IAgDLU,SAAS,EAAEX,MAhDN;;;;;;;IAsDLY,SAAS,EAAEZ,MAtDN;;;;;;IA2DLa,eAAe,EAAEC,QA3DZ;;;;;;IAgELC,gBAAgB,EAAED,QAhEb;;;;;;IAqELE,YAAY,EAAE;MACZjC,IAAI,EAAEc,MADM;MAEZI,OAAO,EAAE;KAvEN;;;;;;;IA8ELgB,SAAS,EAAE;MACTlC,IAAI,EAAE+B,QADG;MAETb,OAAO,EAAEiB;KAhFN;;;;;;;IAuFLC,QAAQ,EAAE;MACRpC,IAAI,EAAE2B,OADE;MAERT,OAAO,EAAE;KAzFN;;;;;;;;IAiGLmB,iBAAiB,EAAE;MACjBrC,IAAI,EAAE+B,QADW;MAEjBb,OAAO,EAAEoB;KAnGN;;;;;;IAyGLC,KAAK,EAAE;MACLvC,IAAI,EAAE2B,OADD;MAELT,OAAO,EAAE;;GAtHA;EAyHbsB,OAAO,EAAE;;;;;IAKDC,iBALC;;;;;;;;;gBAMDC,WANC,GAMa,KAAKC,SAAL,CAAe,KAAK9B,MAApB,CANb;;uBAOc,KAAK+B,YAAL,CAAkBC,GAAlB,CAAsBH,WAAtB,EAAmC,KAAK/B,QAAL,CAAcmC,qBAAjD,CAPd;;;gBAODjC,MAPC;gBAQLkC,MAAM,CAACC,cAAc,CAACnC,MAAD,CAAf,qBAAoC6B,WAApC,4CAAN;gBACAK,MAAM,CAACE,YAAY,CAACpC,MAAM,CAACqC,qBAAP,EAAD,CAAb,qBACOR,WADP,6CAAN;iDAGO,IAAIS,eAAJ,CAAoB;kBACzBC,QAAQ,EAAEvC,MAAM,CAACqC,qBAAP,EADe;kBAEzBlC,cAAc,EAAE,KAAKA,cAFI;kBAGzBG,aAAa,EAAE,KAAKA,aAHK;kBAIzBnB,IAAI,EAAED,aAAa,CAAC,KAAKC,IAAN,CAJM;kBAKzB0B,SAAS,EAAE,KAAKA,SALS;kBAMzBE,SAAS,EAAE,KAAKA,SANS;kBAOzBC,SAAS,EAAE,KAAKA,SAPS;kBAQzBC,eAAe,EAAE,KAAKA,eARG;kBASzBuB,KAAK,EAAE,KAAKC,eAAL,EATkB;kBAUzBtB,gBAAgB,EAAE,KAAKA,gBAVE;kBAWzBC,YAAY,EAAE,KAAKA,YAXM;kBAYzBC,SAAS,EAAE,KAAKA,SAZS;kBAazBE,QAAQ,EAAE,KAAKA,QAbU;kBAczBC,iBAAiB,EAAE,KAAKA,iBAdC;kBAezBE,KAAK,EAAE,KAAKA;iBAfP,CAZF;;;;;;;;;;;;;;;;;;;IAkCPgB,gBAlCO,8BAkCa;UACZC,aAAa,GAAGC,SAAS,CAACC,gBAAgB,EAAjB,EAAqB,UAAAC,MAAM;eAAIA,MAAM,CAACC,GAAP,CAAWC,WAAX,CAAJ;OAA3B,CAA/B;aAEO,SAASC,wBAAT,CAAmCC,OAAnC,EAA4C;YAC7CA,OAAO,CAACC,WAAR,EAAJ,EAA2B;iBAClBR,aAAa,CAACO,OAAO,CAACC,WAAR,GAAsBC,OAAtB,EAAD,CAApB;;OAFJ;KArCK;;;;;;IA+CPC,WA/CO,yBA+CQ;aACNC,gBAAgB,CACf9D,WAAW,CAACmC,OAAZ,CAAoB0B,WAA1B,WADqB,EAEf5D,eAAe,CAACkC,OAAhB,CAAwB0B,WAA9B,WAFqB,CAAvB;KAhDK;;;;;;IAyDPE,cAzDO,4BAyDW;aACT,KAAKC,YAAZ;KA1DK;;;;;;IAgEPC,KAhEO,mBAgEE;MACDjE,WAAW,CAACmC,OAAZ,CAAoB8B,KAA1B;KAjEK;;;;;;IAuEPC,OAvEO,qBAuEI;MACHlE,WAAW,CAACmC,OAAZ,CAAoB+B,OAA1B;KAxEK;;;;;;;IA+EPC,QA/EO,oBA+EGb,MA/EH,EA+EW;UACZA,MAAM,KAAK,KAAKc,OAApB,EAA6B;aACtBA,OAAL,GAAed,MAAf;aACKe,gBAAL;;KAlFG;;;;;;IAyFPC,YAzFO,0BAyFS;MACRtE,WAAW,CAACmC,OAAZ,CAAoBmC,YAA1B;MACMC,6BAAN;;GApNS;EAuNbC,KAAK,oBACAC,YAAY,CAAC,CACd,QADc,EAEd,gBAFc,EAGd,eAHc,EAId,MAJc,EAKd,WALc,EAMd,WANc,EAOd,WAPc,EAQd,iBARc,EASd,kBATc,EAUd,cAVc,EAWd,WAXc,EAYd,UAZc,EAad,mBAbc,EAcd,OAdc,CAAD,EAeZ;WAAM,YAAY;WACdJ,gBAAL;KADC;GAfY,CADZ;;;;;;CAvNP;;AAiPA,SAASE,6BAAT,GAA0C;;;EACxCG,cAAc,CAAC,IAAD,CAAd;MAEMC,UAAU,GAAGC,KAAQ,CACzBC,qBAAqB,CAAC,KAAKb,YAAN,EAAoB,WAApB,CAArB,CACGc,IADH,CAEIC,GAAM,CAAC,UAAAC,GAAG,EAAI;IACZC,iBAAiB,CAACD,GAAG,CAACtB,OAAL,CAAjB;WACOsB,GAAP;GAFI,CAFV,CADyB,EAQzBH,qBAAqB,CAAC,KAAKb,YAAN,EAAoB,SAApB,CARI,CAA3B;OAUKkB,WAAL,CAAiBP,UAAjB,EAA6B,UAAAK,GAAG,EAAI;MAChC,KAAI,CAACG,GAAP;;IACA,KAAI,CAACC,KAAL,CAAWJ,GAAG,CAACrF,IAAf,EAAqBqF,GAArB;GAFF;;;;ACnRU,2BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAZ,SAASK,MAAT,CAAiBC,GAAjB,EAAoC;MAAdC,OAAc,uEAAJ,EAAI;;MAC9BF,MAAM,CAACG,SAAX,EAAsB;;;;EAGtBH,MAAM,CAACG,SAAP,GAAmB,IAAnB;EAEAD,OAAO,GAAGE,IAAI,CAACF,OAAD,EAAU,gBAAV,CAAd;EACAtE,MAAM,CAACyE,MAAP,CAAcC,WAAd,EAA2BJ,OAA3B;EAEAD,GAAG,CAACM,SAAJ,CAAcD,WAAW,CAAC7F,IAA1B,EAAgC6F,WAAhC;;;;;;"}