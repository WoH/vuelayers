{"version":3,"file":"index.js","sources":["src/component/feature/feature.vue?rollup-plugin-vue=script.js","src/component/feature/feature.vue","src/component/feature/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport Feature from 'ol/Feature'\nimport uuid from 'uuid/v4'\nimport { Observable } from 'rxjs'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, mergeAll } from 'rxjs/operators'\nimport { geometryContainer, olCmp, projTransforms, stylesContainer, useMapCmp } from '../../mixin'\nimport { findPointOnSurface, initializeFeature } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasFeature, hasMap } from '../../util/assert'\nimport { isEqual, plainProps } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\n\n/**\n * A vector object for geographic features with a geometry and other attribute properties,\n * similar to the features in vector file formats like **GeoJSON**.\n */\nexport default {\n  name: 'vl-feature',\n  mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n  props: {\n    /**\n     * Feature identifier.\n     * @type {string|number}\n     * @default UUID\n     */\n    id: {\n      type: [String, Number],\n      default: () => uuid(),\n    },\n    /**\n     * All feature properties.\n     * @type {Object}\n     * @default {}\n     */\n    properties: {\n      type: Object,\n      default: () => Object.create(null),\n    },\n  },\n  computed: {\n    /**\n     * **GeoJSON** encoded geometry.\n     * @type {Object|undefined}\n     */\n    geometry () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInDataProj(this.$geometry)\n      }\n    },\n    /**\n     * @return {number[]|undefined}\n     */\n    point () {\n      if (this.pointViewProj && this.resolvedDataProjection) {\n        return this.pointToDataProj(this.pointViewProj)\n      }\n    },\n    geometryViewProj () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInViewProj(this.$geometry)\n      }\n    },\n    pointViewProj () {\n      if (this.rev && this.$geometry) {\n        return findPointOnSurface(this.$geometry)\n      }\n    },\n  },\n  methods: {\n    /**\n     * Create feature without inner style applying, feature level style\n     * will be applied in the layer level style function.\n     * @return {module:ol/Feature~Feature}\n     * @protected\n     */\n    createOlObject () {\n      let feature = new Feature(this.properties)\n\n      initializeFeature(feature, this.id)\n      feature.setGeometry(this.$geometry)\n\n      return feature\n    },\n    /**\n     * @return {{\n     *     getGeometry: function(): (module:ol/geom/Geometry~Geometry|undefined),\n     *     setGeometry: function((module:ol/geom/Geometry~Geometry|undefined)): void\n     *   }|Feature|undefined}\n     * @protected\n     */\n    getGeometryTarget () {\n      return this.$feature\n    },\n    /**\n     * @return {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::geometryContainer.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n        {\n          get feature () { return vm.$feature },\n        },\n      )\n    },\n    /**\n     * @return {module:ol/Feature~Feature|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$feature\n    },\n    /**\n     * Checks if feature lies at `pixel`.\n     * @param {number[]} pixel\n     * @return {boolean}\n     */\n    isAtPixel (pixel) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(\n        pixel,\n        f => f === this.$feature,\n        { layerFilter: l => l === this.$layer },\n      )\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$featuresContainer && this.$featuresContainer.addFeature(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n  },\n  watch: {\n    /**\n     * @param {string|number} value\n     */\n    id (value) {\n      if (this.$feature && value !== this.$feature.getId()) {\n        this.$feature.setId(value)\n      }\n    },\n    /**\n     * @param {Object} value\n     */\n    properties (value) {\n      value = plainProps(value)\n      if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n        this.$feature.setProperties(value)\n      }\n    },\n  },\n  created () {\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    $feature: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    $layer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.layer,\n    },\n    $map: {\n      enumerable: true,\n      get: () => this.$services && this.$services.map,\n    },\n    $view: {\n      enumerable: true,\n      get: () => this.$services && this.$services.view,\n    },\n    $featuresContainer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.featuresContainer,\n    },\n  })\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasFeature(this)\n\n  const getPropValue = prop => this.$feature.get(prop)\n  // all plain properties + geometry\n  const propChanges = observableFromOlEvent(\n    this.$feature,\n    'propertychange',\n    ({ key }) => ({ prop: key, value: getPropValue(key) }),\n  )\n  // id, style and other generic changes\n  const changes = observableFromOlEvent(\n    this.$feature,\n    'change',\n  ).pipe(\n    mapObs(() => Observable.create(obs => {\n      if (this.$feature.getId() !== this.id) {\n        obs.next({ prop: 'id', value: this.$feature.getId() })\n      }\n      // todo style?\n    })),\n    mergeAll(),\n  )\n  // all changes\n  const allChanges = mergeObs(propChanges, changes).pipe(\n    distinctUntilChanged(isEqual),\n  )\n\n  this.subscribeTo(allChanges, ({ prop, value }) => {\n    ++this.rev\n\n    if (prop === 'id') {\n      this.$emit(`update:${prop}`, value)\n    } else if (prop !== this.$feature.getGeometryName()) {\n      this.$emit('update:properties', { ...this.properties, [prop]: value })\n    }\n  })\n}\n","<template>\n  <i :id=\"[$options.name, id].join('-')\" :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :id=\"id\" :properties=\"properties\" :geometry=\"geometry\" :point=\"point\"/>\n  </i>\n</template>\n\n<script>\n  import Feature from 'ol/Feature'\n  import uuid from 'uuid/v4'\n  import { Observable } from 'rxjs'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, mergeAll } from 'rxjs/operators'\n  import { geometryContainer, olCmp, projTransforms, stylesContainer, useMapCmp } from '../../mixin'\n  import { findPointOnSurface, initializeFeature } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasFeature, hasMap } from '../../util/assert'\n  import { isEqual, plainProps } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n\n  /**\n   * A vector object for geographic features with a geometry and other attribute properties,\n   * similar to the features in vector file formats like **GeoJSON**.\n   */\n  export default {\n    name: 'vl-feature',\n    mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n    props: {\n      /**\n       * Feature identifier.\n       * @type {string|number}\n       * @default UUID\n       */\n      id: {\n        type: [String, Number],\n        default: () => uuid(),\n      },\n      /**\n       * All feature properties.\n       * @type {Object}\n       * @default {}\n       */\n      properties: {\n        type: Object,\n        default: () => Object.create(null),\n      },\n    },\n    computed: {\n      /**\n       * **GeoJSON** encoded geometry.\n       * @type {Object|undefined}\n       */\n      geometry () {\n        if (this.rev && this.resolvedDataProjection && this.$geometry) {\n          return this.writeGeometryInDataProj(this.$geometry)\n        }\n      },\n      /**\n       * @return {number[]|undefined}\n       */\n      point () {\n        if (this.pointViewProj && this.resolvedDataProjection) {\n          return this.pointToDataProj(this.pointViewProj)\n        }\n      },\n      geometryViewProj () {\n        if (this.rev && this.resolvedDataProjection && this.$geometry) {\n          return this.writeGeometryInViewProj(this.$geometry)\n        }\n      },\n      pointViewProj () {\n        if (this.rev && this.$geometry) {\n          return findPointOnSurface(this.$geometry)\n        }\n      },\n    },\n    methods: {\n      /**\n       * Create feature without inner style applying, feature level style\n       * will be applied in the layer level style function.\n       * @return {module:ol/Feature~Feature}\n       * @protected\n       */\n      createOlObject () {\n        let feature = new Feature(this.properties)\n\n        initializeFeature(feature, this.id)\n        feature.setGeometry(this.$geometry)\n\n        return feature\n      },\n      /**\n       * @return {{\n       *     getGeometry: function(): (module:ol/geom/Geometry~Geometry|undefined),\n       *     setGeometry: function((module:ol/geom/Geometry~Geometry|undefined)): void\n       *   }|Feature|undefined}\n       * @protected\n       */\n      getGeometryTarget () {\n        return this.$feature\n      },\n      /**\n       * @return {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(\n          this::olCmp.methods.getServices(),\n          this::geometryContainer.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n          {\n            get feature () { return vm.$feature },\n          },\n        )\n      },\n      /**\n       * @return {module:ol/Feature~Feature|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$feature\n      },\n      /**\n       * Checks if feature lies at `pixel`.\n       * @param {number[]} pixel\n       * @return {boolean}\n       */\n      isAtPixel (pixel) {\n        hasMap(this)\n\n        return this.$map.forEachFeatureAtPixel(\n          pixel,\n          f => f === this.$feature,\n          { layerFilter: l => l === this.$layer },\n        )\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$featuresContainer && this.$featuresContainer.addFeature(this)\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unsubscribeAll()\n        this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n    },\n    watch: {\n      /**\n       * @param {string|number} value\n       */\n      id (value) {\n        if (this.$feature && value !== this.$feature.getId()) {\n          this.$feature.setId(value)\n        }\n      },\n      /**\n       * @param {Object} value\n       */\n      properties (value) {\n        value = plainProps(value)\n        if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n          this.$feature.setProperties(value)\n        }\n      },\n    },\n    created () {\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      $feature: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $layer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.layer,\n      },\n      $map: {\n        enumerable: true,\n        get: () => this.$services && this.$services.map,\n      },\n      $view: {\n        enumerable: true,\n        get: () => this.$services && this.$services.view,\n      },\n      $featuresContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.featuresContainer,\n      },\n    })\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasFeature(this)\n\n    const getPropValue = prop => this.$feature.get(prop)\n    // all plain properties + geometry\n    const propChanges = observableFromOlEvent(\n      this.$feature,\n      'propertychange',\n      ({ key }) => ({ prop: key, value: getPropValue(key) }),\n    )\n    // id, style and other generic changes\n    const changes = observableFromOlEvent(\n      this.$feature,\n      'change',\n    ).pipe(\n      mapObs(() => Observable.create(obs => {\n        if (this.$feature.getId() !== this.id) {\n          obs.next({ prop: 'id', value: this.$feature.getId() })\n        }\n        // todo style?\n      })),\n      mergeAll(),\n    )\n    // all changes\n    const allChanges = mergeObs(propChanges, changes).pipe(\n      distinctUntilChanged(isEqual),\n    )\n\n    this.subscribeTo(allChanges, ({ prop, value }) => {\n      ++this.rev\n\n      if (prop === 'id') {\n        this.$emit(`update:${prop}`, value)\n      } else if (prop !== this.$feature.getGeometryName()) {\n        this.$emit('update:properties', { ...this.properties, [prop]: value })\n      }\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Feature from './feature.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Feature, options)\n\n  Vue.component(Feature.name, Feature)\n}\n\nexport default plugin\n\nexport {\n  Feature,\n  plugin as install,\n}\n"],"names":["name","mixins","olCmp","useMapCmp","geometryContainer","stylesContainer","projTransforms","props","id","type","String","Number","default","uuid","properties","Object","create","computed","geometry","rev","resolvedDataProjection","$geometry","writeGeometryInDataProj","point","pointViewProj","pointToDataProj","geometryViewProj","writeGeometryInViewProj","findPointOnSurface","methods","createOlObject","feature","Feature","initializeFeature","setGeometry","getGeometryTarget","$feature","getServices","vm","mergeDescriptors","getStyleTarget","isAtPixel","pixel","hasMap","$map","forEachFeatureAtPixel","f","layerFilter","l","$layer","mount","$featuresContainer","addFeature","subscribeAll","unmount","unsubscribeAll","removeFeature","subscribeToEvents","watch","value","getId","setId","plainProps","isEqual","getProperties","setProperties","created","defineServices","defineProperties","enumerable","get","$olObject","$services","layer","map","$view","view","featuresContainer","hasFeature","getPropValue","prop","propChanges","observableFromOlEvent","key","changes","pipe","mapObs","Observable","obs","next","mergeAll","allChanges","mergeObs","distinctUntilChanged","subscribeTo","$emit","getGeometryName","plugin","Vue","options","installed","pick","assign","component"],"mappings":"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"}