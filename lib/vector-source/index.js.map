{"version":3,"file":"index.js","sources":["src/component/vector-source/source.vue?rollup-plugin-vue=script.js","src/component/vector-source/source.vue","src/component/vector-source/index.js"],"sourcesContent":["\nimport VectorSource from 'ol/source/Vector'\nimport { fetch } from 'whatwg-fetch'\nimport { vectorSource } from '../../mixin'\nimport { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\nimport { constant, difference, isEmpty, isFinite, isFunction, stubArray } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-source-vector',\n  mixins: [vectorSource],\n  props: {\n    /**\n     * Array of GeoJSON features with coordinates in the map view projection.\n     * @type {Object[]} features\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Source loader factory.\n     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n     * @type {(function(): FeatureLoader|undefined)} loaderFactory\n     */\n    loaderFactory: {\n      type: Function,\n      default: defaultLoaderFactory,\n    },\n    /**\n     * Source format factory\n     * @type {(function(): Feature|undefined)} formatFactory\n     */\n    formatFactory: {\n      type: Function,\n      default: defaultFormatFactory,\n    },\n    /**\n     * String or url factory\n     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n     */\n    url: [String, Function],\n    /**\n     * Loading strategy factory.\n     * Extent here in map view projection.\n     * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n     */\n    strategyFactory: {\n      type: Function,\n      default: defaultStrategyFactory,\n    },\n    overlaps: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  computed: {\n    urlFunc () {\n      if (!this.url) {\n        return\n      }\n\n      let url = this.url\n      if (!isFunction(url)) {\n        url = constant(this.url)\n      }\n      // wrap strategy function to transform map view projection to source projection\n      return (extent, resolution, projection) => url(\n        transformExtent(extent, projection, this.resolvedDataProjection),\n        resolution,\n        this.resolvedDataProjection,\n      )\n    },\n    loaderFunc () {\n      const loader = this.loaderFactory(this)\n      // wrap strategy function to transform map view projection to source projection\n      return async (extent, resolution, projection) => {\n        const features = await loader(\n          transformExtent(extent, projection, this.resolvedDataProjection),\n          resolution,\n          this.resolvedDataProjection,\n        )\n\n        if (Array.isArray(features)) {\n          this.addFeatures(features)\n        }\n      }\n    },\n    loadingStrategy () {\n      return this.strategyFactory()\n    },\n    dataFormat () {\n      return this.formatFactory()\n    },\n  },\n  methods: {\n    /**\n     * @return {VectorSource}\n     * @protected\n     */\n    createSource () {\n      return new VectorSource({\n        attributions: this.attributions,\n        features: this._featuresCollection,\n        projection: this.resolvedDataProjection,\n        loader: this.loaderFunc,\n        useSpatialIndex: this.useSpatialIndex,\n        wrapX: this.wrapX,\n        logo: this.logo,\n        strategy: this.loadingStrategy,\n        format: this.dataFormat,\n        url: this.urlFunc,\n        overlaps: this.overlaps,\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::vectorSource.methods.mount()\n      this.addFeatures(this.features)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.clear()\n      this::vectorSource.methods.unmount()\n    },\n  },\n  watch: {\n    features: {\n      deep: true,\n      handler (features) {\n        if (!this.$source) return\n\n        features = features.slice().map(feature => initializeFeature({\n          ...feature,\n        }))\n        this.addFeatures(features)\n\n        const forRemove = difference(this.getFeatures(), features, (a, b) => getFeatureId(a) === getFeatureId(b))\n        this.removeFeatures(forRemove)\n      },\n    },\n    ...makeWatchers([\n      'loadingStrategy',\n      'dataFormat',\n      'urlFunc',\n      'loaderFactory',\n      'formatFactory',\n      'strategyFactory',\n      'overlaps',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {LoadingStrategy}\n */\nfunction defaultStrategyFactory () {\n  return loadingAll\n}\n\n/**\n * @return {GeoJSON}\n */\nfunction defaultFormatFactory () {\n  return createGeoJsonFmt()\n}\n\n/**\n * Default loader for provided URL.\n *\n * @param vm\n * @return {Function}\n */\nfunction defaultLoaderFactory (vm) {\n  return (extent, resolution, projection) => {\n    let url = vm.$source.getUrl()\n    if (isFunction(url)) {\n      url = url(extent, resolution, projection)\n    }\n\n    if (isEmpty(url)) {\n      return []\n    }\n\n    return fetch(url, {\n      credentials: 'same-origin',\n      mode: 'cors',\n    }).then(response => response.text())\n      .then(text => {\n        if (!vm.$source) {\n          return []\n        }\n\n        return vm.$source.getFormat().readFeatures(text, {\n          featureProjection: vm.viewProjection,\n          dataProjection: vm.resolvedDataProjection,\n        })\n      })\n  }\n}\n\nfunction transformExtent (extent, sourceProj, destProj) {\n  extent = extent.slice()\n  if (isFinite(extent[0]) && isFinite(extent[1])) {\n    [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n  }\n  if (isFinite(extent[2]) && isFinite(extent[3])) {\n    [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n  }\n  return extent\n}\n","<script>\n  import VectorSource from 'ol/source/Vector'\n  import { fetch } from 'whatwg-fetch'\n  import { vectorSource } from '../../mixin'\n  import { createGeoJsonFmt, getFeatureId, initializeFeature, loadingAll, transform } from '../../ol-ext'\n  import { constant, difference, isEmpty, isFinite, isFunction, stubArray } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-source-vector',\n    mixins: [vectorSource],\n    props: {\n      /**\n       * Array of GeoJSON features with coordinates in the map view projection.\n       * @type {Object[]} features\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Source loader factory.\n       * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n       * @type {(function(): FeatureLoader|undefined)} loaderFactory\n       */\n      loaderFactory: {\n        type: Function,\n        default: defaultLoaderFactory,\n      },\n      /**\n       * Source format factory\n       * @type {(function(): Feature|undefined)} formatFactory\n       */\n      formatFactory: {\n        type: Function,\n        default: defaultFormatFactory,\n      },\n      /**\n       * String or url factory\n       * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n       */\n      url: [String, Function],\n      /**\n       * Loading strategy factory.\n       * Extent here in map view projection.\n       * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n       */\n      strategyFactory: {\n        type: Function,\n        default: defaultStrategyFactory,\n      },\n      overlaps: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    computed: {\n      urlFunc () {\n        if (!this.url) {\n          return\n        }\n\n        let url = this.url\n        if (!isFunction(url)) {\n          url = constant(this.url)\n        }\n        // wrap strategy function to transform map view projection to source projection\n        return (extent, resolution, projection) => url(\n          transformExtent(extent, projection, this.resolvedDataProjection),\n          resolution,\n          this.resolvedDataProjection,\n        )\n      },\n      loaderFunc () {\n        const loader = this.loaderFactory(this)\n        // wrap strategy function to transform map view projection to source projection\n        return async (extent, resolution, projection) => {\n          const features = await loader(\n            transformExtent(extent, projection, this.resolvedDataProjection),\n            resolution,\n            this.resolvedDataProjection,\n          )\n\n          if (Array.isArray(features)) {\n            this.addFeatures(features)\n          }\n        }\n      },\n      loadingStrategy () {\n        return this.strategyFactory()\n      },\n      dataFormat () {\n        return this.formatFactory()\n      },\n    },\n    methods: {\n      /**\n       * @return {VectorSource}\n       * @protected\n       */\n      createSource () {\n        return new VectorSource({\n          attributions: this.attributions,\n          features: this._featuresCollection,\n          projection: this.resolvedDataProjection,\n          loader: this.loaderFunc,\n          useSpatialIndex: this.useSpatialIndex,\n          wrapX: this.wrapX,\n          logo: this.logo,\n          strategy: this.loadingStrategy,\n          format: this.dataFormat,\n          url: this.urlFunc,\n          overlaps: this.overlaps,\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::vectorSource.methods.mount()\n        this.addFeatures(this.features)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.clear()\n        this::vectorSource.methods.unmount()\n      },\n    },\n    watch: {\n      features: {\n        deep: true,\n        handler (features) {\n          if (!this.$source) return\n\n          features = features.slice().map(feature => initializeFeature({\n            ...feature,\n          }))\n          this.addFeatures(features)\n\n          const forRemove = difference(this.getFeatures(), features, (a, b) => getFeatureId(a) === getFeatureId(b))\n          this.removeFeatures(forRemove)\n        },\n      },\n      ...makeWatchers([\n        'loadingStrategy',\n        'dataFormat',\n        'urlFunc',\n        'loaderFactory',\n        'formatFactory',\n        'strategyFactory',\n        'overlaps',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {LoadingStrategy}\n   */\n  function defaultStrategyFactory () {\n    return loadingAll\n  }\n\n  /**\n   * @return {GeoJSON}\n   */\n  function defaultFormatFactory () {\n    return createGeoJsonFmt()\n  }\n\n  /**\n   * Default loader for provided URL.\n   *\n   * @param vm\n   * @return {Function}\n   */\n  function defaultLoaderFactory (vm) {\n    return (extent, resolution, projection) => {\n      let url = vm.$source.getUrl()\n      if (isFunction(url)) {\n        url = url(extent, resolution, projection)\n      }\n\n      if (isEmpty(url)) {\n        return []\n      }\n\n      return fetch(url, {\n        credentials: 'same-origin',\n        mode: 'cors',\n      }).then(response => response.text())\n        .then(text => {\n          if (!vm.$source) {\n            return []\n          }\n\n          return vm.$source.getFormat().readFeatures(text, {\n            featureProjection: vm.viewProjection,\n            dataProjection: vm.resolvedDataProjection,\n          })\n        })\n    }\n  }\n\n  function transformExtent (extent, sourceProj, destProj) {\n    extent = extent.slice()\n    if (isFinite(extent[0]) && isFinite(extent[1])) {\n      [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n    }\n    if (isFinite(extent[2]) && isFinite(extent[3])) {\n      [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n    }\n    return extent\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Source from './source.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Source, options)\n\n  Vue.component(Source.name, Source)\n}\n\nexport default plugin\n\nexport {\n  Source,\n  plugin as install,\n}\n"],"names":["name","mixins","vectorSource","props","features","type","Array","default","stubArray","loaderFactory","Function","defaultLoaderFactory","formatFactory","defaultFormatFactory","url","String","strategyFactory","defaultStrategyFactory","overlaps","Boolean","computed","urlFunc","isFunction","constant","extent","resolution","projection","transformExtent","resolvedDataProjection","loaderFunc","loader","isArray","addFeatures","loadingStrategy","dataFormat","methods","createSource","VectorSource","attributions","_featuresCollection","useSpatialIndex","wrapX","logo","strategy","format","mount","unmount","clear","watch","deep","handler","$source","slice","map","feature","initializeFeature","forRemove","difference","getFeatures","a","b","getFeatureId","removeFeatures","makeWatchers","scheduleRecreate","loadingAll","createGeoJsonFmt","vm","getUrl","isEmpty","fetch","credentials","mode","then","response","text","getFormat","readFeatures","featureProjection","viewProjection","dataProjection","sourceProj","destProj","isFinite","transform","plugin","Vue","options","installed","pick","Object","assign","Source","component"],"mappings":"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"}