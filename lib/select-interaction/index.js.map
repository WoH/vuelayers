{"version":3,"file":"index.js","sources":["src/component/select-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/select-interaction/interaction.vue","src/component/select-interaction/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\nimport Feature from 'ol/Feature'\nimport SelectInteraction from 'ol/interaction/Select'\nimport Vue from 'vue'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapOp, debounceTime } from 'rxjs/operators'\nimport { interaction, projTransforms, stylesContainer, featuresContainer } from '../../mixin'\nimport { getFeatureId, createStyle, defaultEditStyle, getLayerId, initializeFeature } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasInteraction, hasMap } from '../../util/assert'\nimport { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nexport default {\n  name: 'vl-interaction-select',\n  mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n  props: {\n    /**\n     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n     * @type {function|undefined}\n     */\n    filter: {\n      type: Function,\n      default: constant(true),\n    },\n    /**\n     * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n     * @type {string[]|function|undefined}\n     */\n    layers: {\n      type: [Array, Function],\n      default: undefined,\n    },\n    /**\n     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n     * This only works for the canvas renderer and not for WebGL.\n     * @type {number}\n     */\n    hitTolerance: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n     * features at the clicked map position.\n     * @type {boolean}\n     */\n    multi: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Selected features as array of GeoJSON features with coordinates in the map view projection.\n     * @type {string[]|number[]|Object[]}\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Wrap the world horizontally on the selection overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n     * for `add` and `remove` instead of `toggle`.\n     * @type {function|undefined}\n     */\n    addCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n     * removes all from the selection.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: singleClick,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n     * instead of `toggle`.\n     * @type {function|undefined}\n     */\n    removeCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n     * and removes it if it is.\n     * @type {function|undefined}\n     */\n    toggleCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n  },\n  computed: {\n    layerFilter () {\n      return Array.isArray(this.layers)\n        ? layer => this.layers.includes(getLayerId(layer))\n        : this.layers\n    },\n  },\n  methods: {\n    /**\n     * @return {Select}\n     * @protected\n     */\n    createInteraction () {\n      return new SelectInteraction({\n        features: this._featuresCollection,\n        multi: this.multi,\n        wrapX: this.wrapX,\n        filter: this.filter,\n        layers: this.layerFilter,\n        style: this.createStyleFunc(),\n        addCondition: this.addCondition,\n        condition: this.condition,\n        removeCondition: this.removeCondition,\n        toggleCondition: this.toggleCondition,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n      this.features.forEach(this.select)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unselectAll()\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     * @throws {Error}\n     */\n    select (feature) {\n      hasMap(this)\n\n      if (feature instanceof Vue) {\n        feature = feature.$feature\n      }\n\n      if (!(feature instanceof Feature)) {\n        const featureId = getFeatureId(feature)\n        if (!featureId) {\n          throw new Error('Undefined feature id')\n        }\n\n        feature = undefined\n        forEach(this.$map.getLayers().getArray(), layer => {\n          if (this.layerFilter && !this.layerFilter(layer)) {\n            return false\n          }\n\n          const source = layer.getSource()\n          if (source && isFunction(source.getFeatureById)) {\n            feature = source.getFeatureById(featureId)\n          }\n\n          return !feature\n        })\n      }\n\n      if (!feature) return\n\n      this.addFeature(feature)\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     */\n    unselect (feature) {\n      this.removeFeature(feature)\n    },\n    /**\n     * Removes all features from selection.\n     * @return {void}\n     */\n    unselectAll () {\n      this.clearFeatures()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    features: {\n      deep: true,\n      handler (features) {\n        if (!this.$interaction) return\n\n        features = features.slice().map(feature => initializeFeature({\n          ...feature,\n        }))\n        this.addFeatures(features)\n\n        let forUnselect = difference(this.getFeatures(), features, (a, b) => getFeatureId(a) === getFeatureId(b))\n        this.removeFeatures(forUnselect)\n      },\n    },\n    featuresDataProj: {\n      deep: true,\n      handler (value, prev) {\n        if (!isEqual(value, prev)) {\n          this.$emit('update:features', value)\n        }\n      },\n    },\n    ...makeWatchers([\n      'filter',\n      'hitTolerance',\n      'multi',\n      'wrapX',\n      'addCondition',\n      'condition',\n      'removeCondition',\n      'toggleCondition',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const select = observableFromOlEvent(this._featuresCollection, 'add')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'select', feature: element }))\n    )\n  const unselect = observableFromOlEvent(this._featuresCollection, 'remove')\n    .pipe(\n      mapOp(({ element }) => ({ type: 'unselect', feature: element }))\n    )\n  const events = mergeObs(select, unselect)\n\n  this.subscribeTo(events, evt => this.$emit(evt.type, evt.feature))\n  // emit event to allow `sync` modifier\n  this.subscribeTo(events.pipe(debounceTime(1000 / 60)), () => {\n    this.$emit('update:features', this.featuresDataProj)\n  })\n}\n","<template>\n  <i :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :features=\"featuresDataProj\"/>\n  </i>\n</template>\n\n<script>\n  import { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\n  import Feature from 'ol/Feature'\n  import SelectInteraction from 'ol/interaction/Select'\n  import Vue from 'vue'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapOp, debounceTime } from 'rxjs/operators'\n  import { interaction, projTransforms, stylesContainer, featuresContainer } from '../../mixin'\n  import { getFeatureId, createStyle, defaultEditStyle, getLayerId, initializeFeature } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasInteraction, hasMap } from '../../util/assert'\n  import { constant, difference, forEach, isEqual, isFunction, mapValues, stubArray } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  export default {\n    name: 'vl-interaction-select',\n    mixins: [interaction, featuresContainer, stylesContainer, projTransforms],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n    props: {\n      /**\n       * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n       * @type {function|undefined}\n       */\n      filter: {\n        type: Function,\n        default: constant(true),\n      },\n      /**\n       * A list of layers from which features should be selected. Alternatively, a filter function can be provided.\n       * @type {string[]|function|undefined}\n       */\n      layers: {\n        type: [Array, Function],\n        default: undefined,\n      },\n      /**\n       * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n       * This only works for the canvas renderer and not for WebGL.\n       * @type {number}\n       */\n      hitTolerance: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n       * features at the clicked map position.\n       * @type {boolean}\n       */\n      multi: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * Selected features as array of GeoJSON features with coordinates in the map view projection.\n       * @type {string[]|number[]|Object[]}\n       */\n      features: {\n        type: Array,\n        default: stubArray,\n      },\n      /**\n       * Wrap the world horizontally on the selection overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n       * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n       * for `add` and `remove` instead of `toggle`.\n       * @type {function|undefined}\n       */\n      addCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n       * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n       * removes all from the selection.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: singleClick,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n       * instead of `toggle`.\n       * @type {function|undefined}\n       */\n      removeCondition: {\n        type: Function,\n        default: never,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n       * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n       * and removes it if it is.\n       * @type {function|undefined}\n       */\n      toggleCondition: {\n        type: Function,\n        default: shiftKeyOnly,\n      },\n    },\n    computed: {\n      layerFilter () {\n        return Array.isArray(this.layers)\n          ? layer => this.layers.includes(getLayerId(layer))\n          : this.layers\n      },\n    },\n    methods: {\n      /**\n       * @return {Select}\n       * @protected\n       */\n      createInteraction () {\n        return new SelectInteraction({\n          features: this._featuresCollection,\n          multi: this.multi,\n          wrapX: this.wrapX,\n          filter: this.filter,\n          layers: this.layerFilter,\n          style: this.createStyleFunc(),\n          addCondition: this.addCondition,\n          condition: this.condition,\n          removeCondition: this.removeCondition,\n          toggleCondition: this.toggleCondition,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n        this.features.forEach(this.select)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unselectAll()\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       * @throws {Error}\n       */\n      select (feature) {\n        hasMap(this)\n\n        if (feature instanceof Vue) {\n          feature = feature.$feature\n        }\n\n        if (!(feature instanceof Feature)) {\n          const featureId = getFeatureId(feature)\n          if (!featureId) {\n            throw new Error('Undefined feature id')\n          }\n\n          feature = undefined\n          forEach(this.$map.getLayers().getArray(), layer => {\n            if (this.layerFilter && !this.layerFilter(layer)) {\n              return false\n            }\n\n            const source = layer.getSource()\n            if (source && isFunction(source.getFeatureById)) {\n              feature = source.getFeatureById(featureId)\n            }\n\n            return !feature\n          })\n        }\n\n        if (!feature) return\n\n        this.addFeature(feature)\n      },\n      /**\n       * @param {Object|Vue|Feature|string|number} feature\n       * @return {void}\n       */\n      unselect (feature) {\n        this.removeFeature(feature)\n      },\n      /**\n       * Removes all features from selection.\n       * @return {void}\n       */\n      unselectAll () {\n        this.clearFeatures()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRefresh()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      features: {\n        deep: true,\n        handler (features) {\n          if (!this.$interaction) return\n\n          features = features.slice().map(feature => initializeFeature({\n            ...feature,\n          }))\n          this.addFeatures(features)\n\n          let forUnselect = difference(this.getFeatures(), features, (a, b) => getFeatureId(a) === getFeatureId(b))\n          this.removeFeatures(forUnselect)\n        },\n      },\n      featuresDataProj: {\n        deep: true,\n        handler (value, prev) {\n          if (!isEqual(value, prev)) {\n            this.$emit('update:features', value)\n          }\n        },\n      },\n      ...makeWatchers([\n        'filter',\n        'hitTolerance',\n        'multi',\n        'wrapX',\n        'addCondition',\n        'condition',\n        'removeCondition',\n        'toggleCondition',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const select = observableFromOlEvent(this._featuresCollection, 'add')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'select', feature: element }))\n      )\n    const unselect = observableFromOlEvent(this._featuresCollection, 'remove')\n      .pipe(\n        mapOp(({ element }) => ({ type: 'unselect', feature: element }))\n      )\n    const events = mergeObs(select, unselect)\n\n    this.subscribeTo(events, evt => this.$emit(evt.type, evt.feature))\n    // emit event to allow `sync` modifier\n    this.subscribeTo(events.pipe(debounceTime(1000 / 60)), () => {\n      this.$emit('update:features', this.featuresDataProj)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["name","mixins","interaction","featuresContainer","stylesContainer","projTransforms","stubVNode","empty","attrs","class","$options","props","filter","type","Function","default","constant","layers","Array","undefined","hitTolerance","Number","multi","Boolean","features","stubArray","wrapX","addCondition","never","condition","singleClick","removeCondition","toggleCondition","shiftKeyOnly","computed","layerFilter","isArray","layer","includes","getLayerId","methods","createInteraction","SelectInteraction","_featuresCollection","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","map","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","forEach","select","unmount","unselectAll","hasMap","Vue","$feature","Feature","featureId","getFeatureId","Error","$map","getLayers","getArray","source","getSource","isFunction","getFeatureById","addFeature","unselect","removeFeature","clearFeatures","setStyle","_styles","scheduleRefresh","subscribeAll","subscribeToInteractionChanges","watch","deep","handler","slice","initializeFeature","addFeatures","forUnselect","difference","getFeatures","a","b","removeFeatures","featuresDataProj","value","prev","isEqual","$emit","makeWatchers","scheduleRecreate","hasInteraction","observableFromOlEvent","pipe","mapOp","element","events","mergeObs","subscribeTo","evt","debounceTime","plugin","options","installed","pick","Object","assign","Interaction","component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA,aAAe;EACbA,IAAI,EAAE,uBADO;EAEbC,MAAM,EAAE,CAACC,WAAD,EAAcC,iBAAd,EAAiCC,eAAjC,EAAkDC,cAAlD,CAFK;EAGbC,SAAS,EAAE;IACTC,KAAK,EAAE,KADE;IAETC,KAFS,mBAEA;aACA;QACLC,KAAK,EAAE,KAAKC,QAAL,CAAcV;OADvB;;GANS;EAWbW,KAAK,EAAE;;;;;IAKLC,MAAM,EAAE;MACNC,IAAI,EAAEC,QADA;MAENC,OAAO,EAAEC,QAAQ,CAAC,IAAD;KAPd;;;;;;IAaLC,MAAM,EAAE;MACNJ,IAAI,EAAE,CAACK,KAAD,EAAQJ,QAAR,CADA;MAENC,OAAO,EAAEI;KAfN;;;;;;;IAsBLC,YAAY,EAAE;MACZP,IAAI,EAAEQ,MADM;MAEZN,OAAO,EAAE;KAxBN;;;;;;;IA+BLO,KAAK,EAAE;MACLT,IAAI,EAAEU,OADD;MAELR,OAAO,EAAE;KAjCN;;;;;;IAuCLS,QAAQ,EAAE;MACRX,IAAI,EAAEK,KADE;MAERH,OAAO,EAAEU;KAzCN;;;;;;IA+CLC,KAAK,EAAE;MACLb,IAAI,EAAEU,OADD;MAELR,OAAO,EAAE;KAjDN;;;;;;;;IAyDLY,YAAY,EAAE;MACZd,IAAI,EAAEC,QADM;MAEZC,OAAO,EAAEa;KA3DN;;;;;;;;;IAoELC,SAAS,EAAE;MACThB,IAAI,EAAEC,QADG;MAETC,OAAO,EAAEe;KAtEN;;;;;;;;IA8ELC,eAAe,EAAE;MACflB,IAAI,EAAEC,QADS;MAEfC,OAAO,EAAEa;KAhFN;;;;;;;;;IAyFLI,eAAe,EAAE;MACfnB,IAAI,EAAEC,QADS;MAEfC,OAAO,EAAEkB;;GAtGA;EAyGbC,QAAQ,EAAE;IACRC,WADQ,yBACO;;;aACNjB,KAAK,CAACkB,OAAN,CAAc,KAAKnB,MAAnB,IACH,UAAAoB,KAAK;eAAI,KAAI,CAACpB,MAAL,CAAYqB,QAAZ,CAAqBC,UAAU,CAACF,KAAD,CAA/B,CAAJ;OADF,GAEH,KAAKpB,MAFT;;GA3GS;EAgHbuB,OAAO,EAAE;;;;;IAKPC,iBALO,+BAKc;aACZ,IAAIC,iBAAJ,CAAsB;QAC3BlB,QAAQ,EAAE,KAAKmB,mBADY;QAE3BrB,KAAK,EAAE,KAAKA,KAFe;QAG3BI,KAAK,EAAE,KAAKA,KAHe;QAI3Bd,MAAM,EAAE,KAAKA,MAJc;QAK3BK,MAAM,EAAE,KAAKkB,WALc;QAM3BS,KAAK,EAAE,KAAKC,eAAL,EANoB;QAO3BlB,YAAY,EAAE,KAAKA,YAPQ;QAQ3BE,SAAS,EAAE,KAAKA,SARW;QAS3BE,eAAe,EAAE,KAAKA,eATK;QAU3BC,eAAe,EAAE,KAAKA;OAVjB,CAAP;KANK;;;;;;IAuBPc,gBAvBO,8BAuBa;UACZC,aAAa,GAAGC,SAAS,CAACC,gBAAgB,EAAjB,EAAqB,UAAAC,MAAM;eAAIA,MAAM,CAACC,GAAP,CAAWC,WAAX,CAAJ;OAA3B,CAA/B;aAEO,SAASC,wBAAT,CAAmCC,OAAnC,EAA4C;YAC7CA,OAAO,CAACC,WAAR,EAAJ,EAA2B;iBAClBR,aAAa,CAACO,OAAO,CAACC,WAAR,GAAsBC,OAAtB,EAAD,CAApB;;OAFJ;KA1BK;;;;;;IAoCPC,WApCO,yBAoCQ;aACNC,gBAAgB,CACfxD,WAAW,CAACsC,OAAZ,CAAoBiB,WAA1B,WADqB,EAEfrD,eAAe,CAACoC,OAAhB,CAAwBiB,WAA9B,WAFqB,CAAvB;KArCK;;;;;;IA8CPE,cA9CO,4BA8CW;aACT,KAAKC,YAAZ;KA/CK;;;;;;IAqDPC,KArDO,mBAqDE;MACD3D,WAAW,CAACsC,OAAZ,CAAoBqB,KAA1B;WACKrC,QAAL,CAAcsC,OAAd,CAAsB,KAAKC,MAA3B;KAvDK;;;;;;IA6DPC,OA7DO,qBA6DI;WACJC,WAAL;MACM/D,WAAW,CAACsC,OAAZ,CAAoBwB,OAA1B;KA/DK;;;;;;;IAsEPD,MAtEO,kBAsECT,OAtED,EAsEU;;;MACfY,MAAM,CAAC,IAAD,CAAN;;UAEIZ,OAAO,YAAYa,GAAvB,EAA4B;QAC1Bb,OAAO,GAAGA,OAAO,CAACc,QAAlB;;;UAGE,EAAEd,OAAO,YAAYe,OAArB,CAAJ,EAAmC;YAC3BC,SAAS,GAAGC,YAAY,CAACjB,OAAD,CAA9B;;YACI,CAACgB,SAAL,EAAgB;gBACR,IAAIE,KAAJ,CAAU,sBAAV,CAAN;;;QAGFlB,OAAO,GAAGnC,SAAV;QACA2C,OAAO,CAAC,KAAKW,IAAL,CAAUC,SAAV,GAAsBC,QAAtB,EAAD,EAAmC,UAAAtC,KAAK,EAAI;cAC7C,MAAI,CAACF,WAAL,IAAoB,CAAC,MAAI,CAACA,WAAL,CAAiBE,KAAjB,CAAzB,EAAkD;mBACzC,KAAP;;;cAGIuC,MAAM,GAAGvC,KAAK,CAACwC,SAAN,EAAf;;cACID,MAAM,IAAIE,UAAU,CAACF,MAAM,CAACG,cAAR,CAAxB,EAAiD;YAC/CzB,OAAO,GAAGsB,MAAM,CAACG,cAAP,CAAsBT,SAAtB,CAAV;;;iBAGK,CAAChB,OAAR;SAVK,CAAP;;;UAcE,CAACA,OAAL,EAAc;WAET0B,UAAL,CAAgB1B,OAAhB;KApGK;;;;;;IA0GP2B,QA1GO,oBA0GG3B,OA1GH,EA0GY;WACZ4B,aAAL,CAAmB5B,OAAnB;KA3GK;;;;;;IAiHPW,WAjHO,yBAiHQ;WACRkB,aAAL;KAlHK;;;;;;;IAyHPC,QAzHO,oBAyHGlC,MAzHH,EAyHW;UACZA,MAAM,KAAK,KAAKmC,OAApB,EAA6B;aACtBA,OAAL,GAAenC,MAAf;aACKoC,eAAL;;KA5HG;;;;;;IAmIPC,YAnIO,0BAmIS;MACRrF,WAAW,CAACsC,OAAZ,CAAoB+C,YAA1B;MACMC,6BAAN;;GArPS;EAwPbC,KAAK;IACHjE,QAAQ,EAAE;MACRkE,IAAI,EAAE,IADE;MAERC,OAFQ,mBAECnE,QAFD,EAEW;YACb,CAAC,KAAKoC,YAAV,EAAwB;QAExBpC,QAAQ,GAAGA,QAAQ,CAACoE,KAAT,GAAiBzC,GAAjB,CAAqB,UAAAG,OAAO;iBAAIuC,iBAAiB,mBACvDvC,OADuD,EAArB;SAA5B,CAAX;aAGKwC,WAAL,CAAiBtE,QAAjB;YAEIuE,WAAW,GAAGC,UAAU,CAAC,KAAKC,WAAL,EAAD,EAAqBzE,QAArB,EAA+B,UAAC0E,CAAD,EAAIC,CAAJ;iBAAU5B,YAAY,CAAC2B,CAAD,CAAZ,KAAoB3B,YAAY,CAAC4B,CAAD,CAA1C;SAA/B,CAA5B;aACKC,cAAL,CAAoBL,WAApB;;KAZD;IAeHM,gBAAgB,EAAE;MAChBX,IAAI,EAAE,IADU;MAEhBC,OAFgB,mBAEPW,KAFO,EAEAC,IAFA,EAEM;YAChB,CAACC,OAAO,CAACF,KAAD,EAAQC,IAAR,CAAZ,EAA2B;eACpBE,KAAL,CAAW,iBAAX,EAA8BH,KAA9B;;;;KAIHI,YAAY,CAAC,CACd,QADc,EAEd,cAFc,EAGd,OAHc,EAId,OAJc,EAKd,cALc,EAMd,WANc,EAOd,iBAPc,EAQd,iBARc,CAAD,EASZ;WAAM,YAAY;WACdC,gBAAL;KADC;GATY,CAvBZ;;;;;;CAxPP;;AAkSA,SAASnB,6BAAT,GAA0C;;;EACxCoB,cAAc,CAAC,IAAD,CAAd;MAEM7C,MAAM,GAAG8C,qBAAqB,CAAC,KAAKlE,mBAAN,EAA2B,KAA3B,CAArB,CACZmE,IADY,CAEXC,GAAK,CAAC;QAAGC,OAAH,QAAGA,OAAH;WAAkB;MAAEnG,IAAI,EAAE,QAAR;MAAkByC,OAAO,EAAE0D;KAA7C;GAAD,CAFM,CAAf;MAIM/B,QAAQ,GAAG4B,qBAAqB,CAAC,KAAKlE,mBAAN,EAA2B,QAA3B,CAArB,CACdmE,IADc,CAEbC,GAAK,CAAC;QAAGC,OAAH,SAAGA,OAAH;WAAkB;MAAEnG,IAAI,EAAE,UAAR;MAAoByC,OAAO,EAAE0D;KAA/C;GAAD,CAFQ,CAAjB;MAIMC,MAAM,GAAGC,KAAQ,CAACnD,MAAD,EAASkB,QAAT,CAAvB;OAEKkC,WAAL,CAAiBF,MAAjB,EAAyB,UAAAG,GAAG;WAAI,MAAI,CAACX,KAAL,CAAWW,GAAG,CAACvG,IAAf,EAAqBuG,GAAG,CAAC9D,OAAzB,CAAJ;GAA5B,EAbwC;;OAenC6D,WAAL,CAAiBF,MAAM,CAACH,IAAP,CAAYO,YAAY,CAAC,OAAO,EAAR,CAAxB,CAAjB,EAAuD,YAAM;IAC3D,MAAI,CAACZ,KAAL,CAAW,iBAAX,EAA8B,MAAI,CAACJ,gBAAnC;GADF;;;;ACnUU,2BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAZ,SAASiB,MAAT,CAAiBnD,MAAjB,EAAoC;MAAdoD,OAAc,uEAAJ,EAAI;;MAC9BD,MAAM,CAACE,SAAX,EAAsB;;;;EAGtBF,MAAM,CAACE,SAAP,GAAmB,IAAnB;EAEAD,OAAO,GAAGE,IAAI,CAACF,OAAD,EAAU,gBAAV,CAAd;EACAG,MAAM,CAACC,MAAP,CAAcC,WAAd,EAA2BL,OAA3B;EAEApD,MAAG,CAAC0D,SAAJ,CAAcD,WAAW,CAAC5H,IAA1B,EAAgC4H,WAAhC;;;;;;"}