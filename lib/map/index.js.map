{"version":3,"file":"index.js","sources":["src/component/map/map.vue?rollup-plugin-vue=script.js","src/component/map/map.vue","src/component/map/view.vue?rollup-plugin-vue=script.js","src/component/map/view.vue","src/component/map/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport { defaults as createDefaultControls } from 'ol/control'\nimport { defaults as createDefaultInteractions } from 'ol/interaction'\nimport VectorLayer from 'ol/layer/Vector'\nimport Collection from 'ol/Collection'\nimport Map from 'ol/Map'\nimport VectorSource from 'ol/source/Vector'\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, overlaysContainer, layersContainer, interactionsContainer, featuresContainer, projTransforms } from '../../mixin'\nimport { initializeInteraction, setMapDataProjection } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasMap, hasView } from '../../util/assert'\nimport { isEqual } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n * rendering and low level interaction events.\n */\nexport default {\n  name: 'vl-map',\n  mixins: [\n    olCmp,\n    layersContainer,\n    interactionsContainer,\n    overlaysContainer,\n    featuresContainer,\n    projTransforms,\n  ],\n  props: {\n    /**\n     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n     * value is used to configure controls.\n     * @type {Object|boolean}\n     * @todo remove when vl-control-* components will be ready\n     */\n    defaultControls: {\n      type: [Object, Boolean],\n      default: true,\n    },\n    /**\n     * Options for default interactions added to the map by default. Object\n     * value is used to configure default interactions.\n     * @type {Object|boolean}\n     */\n    defaultInteractions: {\n      type: [Object, Boolean],\n      default: () => ({}),\n    },\n    /**\n     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n     * events on is the component root element.\n     * @type {string|Element|Document}\n     */\n    keyboardEventTarget: [String, Element, Document],\n    /**\n     * When set to `true`, tiles will be loaded during animations.\n     * @type {boolean}\n     */\n    loadTilesWhileAnimating: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * When set to `true`, tiles will be loaded while interacting with the map.\n     * @type {boolean}\n     */\n    loadTilesWhileInteracting: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n     * Increasing this value can make it easier to click on the map.\n     * @type {Number}\n     */\n    moveTolerance: {\n      type: Number,\n      default: 1,\n    },\n    /**\n     * The ratio between physical pixels and device-independent pixels (dips) on the device.\n     * @type {number}\n     */\n    pixelRatio: {\n      type: Number,\n      default: () => window.devicePixelRatio || 1,\n    },\n    /**\n     * Maximum number tiles to load simultaneously.\n     * @type {number}\n     */\n    maxTilesLoading: {\n      type: Number,\n      default: 16,\n    },\n    /**\n     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n     * @type {number|string}\n     */\n    tabindex: [String, Number],\n    /**\n     * Projection for input/output coordinates in plain data.\n     * @type {string}\n     */\n    dataProjection: String,\n    /**\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  methods: {\n    /**\n     * @return {module:ol/PluggableMap~PluggableMap}\n     * @protected\n     */\n    createOlObject () {\n      const map = new Map({\n        loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n        loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n        pixelRatio: this.pixelRatio,\n        moveTolerance: this.moveTolerance,\n        keyboardEventTarget: this.keyboardEventTarget,\n        maxTilesLoading: this.maxTilesLoading,\n        controls: this._controlsCollection,\n        interactions: this._interactionsCollection,\n        layers: this._layersCollection,\n        overlays: this._overlaysCollection,\n        view: this._view,\n      })\n\n      setMapDataProjection(map, this.dataProjection)\n      this._featuresOverlay.setMap(map)\n\n      return map\n    },\n    /**\n     * @param {number[]} pixel\n     * @return {number[]} Coordinates in the map data projection.\n     */\n    getCoordinateFromPixel (pixel) {\n      hasMap(this)\n\n      let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n      return this.pointToDataProj(coordinate)\n    },\n    /**\n     * @param {number[]} coordinate Coordinates in map data projection\n     * @return {number[]}\n     */\n    getPixelFromCoordinate (coordinate) {\n      hasMap(this)\n\n      return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n    },\n    /**\n     * Triggers focus on map container.\n     * @return {void}\n     */\n    focus () {\n      this.$el.focus()\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachFeatureAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachLayerAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {Object} [opts]\n     */\n    getFeaturesAtPixel (pixel, opts = {}) {\n      hasMap(this)\n\n      return this.$map.getFeaturesAtPixel(pixel, opts)\n    },\n    /**\n     * Updates map size and re-renders map.\n     * @return {Promise}\n     */\n    refresh () {\n      this.updateSize()\n\n      return this.render().then(() => this::olCmp.methods.refresh())\n    },\n    /**\n     * @return {Promise}\n     */\n    render () {\n      return new Promise(resolve => {\n        hasMap(this)\n\n        this.$map.once('postrender', () => resolve())\n        this.$map.render()\n      })\n    },\n    /**\n     * Updates map size.\n     * @return {void}\n     */\n    updateSize () {\n      hasMap(this)\n\n      this.$map.updateSize()\n    },\n    /**\n     * @param {module:ol/View~View|Vue|undefined} view\n     * @return {void}\n     * @protected\n     */\n    setView (view) {\n      view = view instanceof Vue ? view.$view : view\n      view || (view = new View())\n\n      if (view !== this._view) {\n        this._view = view\n      }\n      if (this.$map && view !== this.$map.getView()) {\n        this.$map.setView(view)\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      hasMap(this)\n\n      this.$map.setTarget(this.$el)\n      this.$nextTick(::this.updateSize)\n\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      hasMap(this)\n\n      this.clearFeatures()\n      this.clearLayers()\n      this.clearInteractions()\n      this.clearOverlays()\n\n      this.unsubscribeAll()\n      this.$map.setTarget(null)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::layersContainer.methods.getServices(),\n        this::interactionsContainer.methods.getServices(),\n        this::overlaysContainer.methods.getServices(),\n        this::featuresContainer.methods.getServices(),\n        {\n          get map () { return vm.$map },\n          get view () { return vm.$view },\n          get viewContainer () { return vm },\n        },\n      )\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'keyboardEventTarget',\n      'loadTilesWhileAnimating',\n      'loadTilesWhileInteracting',\n      'moveTolerance',\n      'pixelRatio',\n      'renderer',\n      'maxTilesLoading',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n    controls (value) {\n      if (value === false) {\n        this._controlsCollection.clear()\n        return\n      }\n\n      value = typeof value === 'object' ? value : undefined\n      this._controlsCollection.clear()\n      this._controlsCollection.extend(createDefaultControls(value).getArray())\n    },\n    wrapX (value) {\n      if (this._featuresOverlay == null) return\n\n      this._featuresOverlay.setSource(new VectorSource({\n        features: this._featuresCollection,\n        wrapX: value,\n      }))\n    },\n    dataProjection (value) {\n      if (!this.$map) return\n\n      setMapDataProjection(this.$map, value)\n      this.scheduleRefresh()\n    },\n  },\n  created () {\n    this._view = new View()\n    // todo make controls handling like with interactions\n    this._controlsCollection = this.defaultControls !== false\n      ? createDefaultControls(typeof this.defaultControls === 'object' ? this.defaultControls : undefined)\n      : new Collection()\n    // todo initialize without interactions and provide vl-interaction-default component\n    this._interactionsCollection = this.defaultInteractions !== false\n      ? createDefaultInteractions(typeof this.defaultInteractions === 'object' ? this.defaultInteractions : undefined)\n      : new Collection()\n    this._interactionsCollection.forEach(interaction => initializeInteraction(interaction))\n    // prepare default overlay\n    this._featuresOverlay = new VectorLayer({\n      source: new VectorSource({\n        features: this._featuresCollection,\n        wrapX: this.wrapX,\n      }),\n    })\n\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * OpenLayers map instance.\n     * @type {module:ol/PluggableMap~PluggableMap|undefined}\n     */\n    $map: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    /**\n     * OpenLayers view instance.\n     * @type {module:ol/View~View}\n     */\n    $view: {\n      enumerable: true,\n      get: () => this._view,\n    },\n  })\n}\n\n/**\n * Subscribe to OL map events.\n *\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasMap(this)\n  hasView(this)\n\n  const ft = 1000 / 60\n  // pointer\n  const pointerEvents = mergeObs(\n    observableFromOlEvent(this.$map, [\n      'click',\n      'dblclick',\n      'singleclick',\n    ]),\n    observableFromOlEvent(this.$map, [\n      'pointerdrag',\n      'pointermove',\n    ]).pipe(\n      throttleTime(ft),\n      distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n    ),\n  ).pipe(\n    mapObs(evt => ({\n      ...evt,\n      coordinate: this.pointToDataProj(evt.coordinate),\n    })),\n  )\n  // other\n  const otherEvents = observableFromOlEvent(this.$map, [\n    'movestart',\n    'moveend',\n    'postrender',\n    'rendercomplete',\n    'precompose',\n    'postcompose',\n    'rendercomplete',\n  ])\n\n  const events = mergeObs(pointerEvents, otherEvents)\n\n  this.subscribeTo(events, evt => {\n    this.$emit(evt.type, evt)\n  })\n}\n","<template>\n  <div :class=\"[$options.name]\" :tabindex=\"tabindex\">\n    <slot/>\n  </div>\n</template>\n\n<script>\n  import { defaults as createDefaultControls } from 'ol/control'\n  import { defaults as createDefaultInteractions } from 'ol/interaction'\n  import VectorLayer from 'ol/layer/Vector'\n  import Collection from 'ol/Collection'\n  import Map from 'ol/Map'\n  import VectorSource from 'ol/source/Vector'\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, overlaysContainer, layersContainer, interactionsContainer, featuresContainer, projTransforms } from '../../mixin'\n  import { initializeInteraction, setMapDataProjection } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasMap, hasView } from '../../util/assert'\n  import { isEqual } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n   * rendering and low level interaction events.\n   */\n  export default {\n    name: 'vl-map',\n    mixins: [\n      olCmp,\n      layersContainer,\n      interactionsContainer,\n      overlaysContainer,\n      featuresContainer,\n      projTransforms,\n    ],\n    props: {\n      /**\n       * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n       * value is used to configure controls.\n       * @type {Object|boolean}\n       * @todo remove when vl-control-* components will be ready\n       */\n      defaultControls: {\n        type: [Object, Boolean],\n        default: true,\n      },\n      /**\n       * Options for default interactions added to the map by default. Object\n       * value is used to configure default interactions.\n       * @type {Object|boolean}\n       */\n      defaultInteractions: {\n        type: [Object, Boolean],\n        default: () => ({}),\n      },\n      /**\n       * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n       * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n       * events on is the component root element.\n       * @type {string|Element|Document}\n       */\n      keyboardEventTarget: [String, Element, Document],\n      /**\n       * When set to `true`, tiles will be loaded during animations.\n       * @type {boolean}\n       */\n      loadTilesWhileAnimating: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * When set to `true`, tiles will be loaded while interacting with the map.\n       * @type {boolean}\n       */\n      loadTilesWhileInteracting: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n       * Increasing this value can make it easier to click on the map.\n       * @type {Number}\n       */\n      moveTolerance: {\n        type: Number,\n        default: 1,\n      },\n      /**\n       * The ratio between physical pixels and device-independent pixels (dips) on the device.\n       * @type {number}\n       */\n      pixelRatio: {\n        type: Number,\n        default: () => window.devicePixelRatio || 1,\n      },\n      /**\n       * Maximum number tiles to load simultaneously.\n       * @type {number}\n       */\n      maxTilesLoading: {\n        type: Number,\n        default: 16,\n      },\n      /**\n       * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n       * @type {number|string}\n       */\n      tabindex: [String, Number],\n      /**\n       * Projection for input/output coordinates in plain data.\n       * @type {string}\n       */\n      dataProjection: String,\n      /**\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    methods: {\n      /**\n       * @return {module:ol/PluggableMap~PluggableMap}\n       * @protected\n       */\n      createOlObject () {\n        const map = new Map({\n          loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n          loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n          pixelRatio: this.pixelRatio,\n          moveTolerance: this.moveTolerance,\n          keyboardEventTarget: this.keyboardEventTarget,\n          maxTilesLoading: this.maxTilesLoading,\n          controls: this._controlsCollection,\n          interactions: this._interactionsCollection,\n          layers: this._layersCollection,\n          overlays: this._overlaysCollection,\n          view: this._view,\n        })\n\n        setMapDataProjection(map, this.dataProjection)\n        this._featuresOverlay.setMap(map)\n\n        return map\n      },\n      /**\n       * @param {number[]} pixel\n       * @return {number[]} Coordinates in the map data projection.\n       */\n      getCoordinateFromPixel (pixel) {\n        hasMap(this)\n\n        let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n        return this.pointToDataProj(coordinate)\n      },\n      /**\n       * @param {number[]} coordinate Coordinates in map data projection\n       * @return {number[]}\n       */\n      getPixelFromCoordinate (coordinate) {\n        hasMap(this)\n\n        return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n      },\n      /**\n       * Triggers focus on map container.\n       * @return {void}\n       */\n      focus () {\n        this.$el.focus()\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachFeatureAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachLayerAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {Object} [opts]\n       */\n      getFeaturesAtPixel (pixel, opts = {}) {\n        hasMap(this)\n\n        return this.$map.getFeaturesAtPixel(pixel, opts)\n      },\n      /**\n       * Updates map size and re-renders map.\n       * @return {Promise}\n       */\n      refresh () {\n        this.updateSize()\n\n        return this.render().then(() => this::olCmp.methods.refresh())\n      },\n      /**\n       * @return {Promise}\n       */\n      render () {\n        return new Promise(resolve => {\n          hasMap(this)\n\n          this.$map.once('postrender', () => resolve())\n          this.$map.render()\n        })\n      },\n      /**\n       * Updates map size.\n       * @return {void}\n       */\n      updateSize () {\n        hasMap(this)\n\n        this.$map.updateSize()\n      },\n      /**\n       * @param {module:ol/View~View|Vue|undefined} view\n       * @return {void}\n       * @protected\n       */\n      setView (view) {\n        view = view instanceof Vue ? view.$view : view\n        view || (view = new View())\n\n        if (view !== this._view) {\n          this._view = view\n        }\n        if (this.$map && view !== this.$map.getView()) {\n          this.$map.setView(view)\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        hasMap(this)\n\n        this.$map.setTarget(this.$el)\n        this.$nextTick(::this.updateSize)\n\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        hasMap(this)\n\n        this.clearFeatures()\n        this.clearLayers()\n        this.clearInteractions()\n        this.clearOverlays()\n\n        this.unsubscribeAll()\n        this.$map.setTarget(null)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(\n          this::olCmp.methods.getServices(),\n          this::layersContainer.methods.getServices(),\n          this::interactionsContainer.methods.getServices(),\n          this::overlaysContainer.methods.getServices(),\n          this::featuresContainer.methods.getServices(),\n          {\n            get map () { return vm.$map },\n            get view () { return vm.$view },\n            get viewContainer () { return vm },\n          },\n        )\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'keyboardEventTarget',\n        'loadTilesWhileAnimating',\n        'loadTilesWhileInteracting',\n        'moveTolerance',\n        'pixelRatio',\n        'renderer',\n        'maxTilesLoading',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n      controls (value) {\n        if (value === false) {\n          this._controlsCollection.clear()\n          return\n        }\n\n        value = typeof value === 'object' ? value : undefined\n        this._controlsCollection.clear()\n        this._controlsCollection.extend(createDefaultControls(value).getArray())\n      },\n      wrapX (value) {\n        if (this._featuresOverlay == null) return\n\n        this._featuresOverlay.setSource(new VectorSource({\n          features: this._featuresCollection,\n          wrapX: value,\n        }))\n      },\n      dataProjection (value) {\n        if (!this.$map) return\n\n        setMapDataProjection(this.$map, value)\n        this.scheduleRefresh()\n      },\n    },\n    created () {\n      this._view = new View()\n      // todo make controls handling like with interactions\n      this._controlsCollection = this.defaultControls !== false\n        ? createDefaultControls(typeof this.defaultControls === 'object' ? this.defaultControls : undefined)\n        : new Collection()\n      // todo initialize without interactions and provide vl-interaction-default component\n      this._interactionsCollection = this.defaultInteractions !== false\n        ? createDefaultInteractions(typeof this.defaultInteractions === 'object' ? this.defaultInteractions : undefined)\n        : new Collection()\n      this._interactionsCollection.forEach(interaction => initializeInteraction(interaction))\n      // prepare default overlay\n      this._featuresOverlay = new VectorLayer({\n        source: new VectorSource({\n          features: this._featuresCollection,\n          wrapX: this.wrapX,\n        }),\n      })\n\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * OpenLayers map instance.\n       * @type {module:ol/PluggableMap~PluggableMap|undefined}\n       */\n      $map: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      /**\n       * OpenLayers view instance.\n       * @type {module:ol/View~View}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this._view,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OL map events.\n   *\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasMap(this)\n    hasView(this)\n\n    const ft = 1000 / 60\n    // pointer\n    const pointerEvents = mergeObs(\n      observableFromOlEvent(this.$map, [\n        'click',\n        'dblclick',\n        'singleclick',\n      ]),\n      observableFromOlEvent(this.$map, [\n        'pointerdrag',\n        'pointermove',\n      ]).pipe(\n        throttleTime(ft),\n        distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n      ),\n    ).pipe(\n      mapObs(evt => ({\n        ...evt,\n        coordinate: this.pointToDataProj(evt.coordinate),\n      })),\n    )\n    // other\n    const otherEvents = observableFromOlEvent(this.$map, [\n      'movestart',\n      'moveend',\n      'postrender',\n      'rendercomplete',\n      'precompose',\n      'postcompose',\n      'rendercomplete',\n    ])\n\n    const events = mergeObs(pointerEvents, otherEvents)\n\n    this.subscribeTo(events, evt => {\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","//\n//\n//\n//\n//\n//\n\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, projTransforms } from '../../mixin'\nimport { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\nimport { observableFromOlChangeEvent } from '../../rx-ext'\nimport { hasView } from '../../util/assert'\nimport { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n * **resolution**, and **rotation** of the map.\n */\nexport default {\n  name: 'vl-view',\n  mixins: [olCmp, projTransforms],\n  props: {\n    /**\n     * The center coordinate in the view projection.\n     * @type {number[]}\n     * @default [0, 0]\n     */\n    center: {\n      type: Array,\n      default: () => [0, 0],\n      validator: arrayLengthValidator(2),\n    },\n    constrainRotation: {\n      type: [Boolean, Number],\n      default: true,\n    },\n    enableRotation: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * The extent that constrains the center defined in the view projection,\n     * in other words, center cannot be set outside this extent.\n     * @default undefined\n     */\n    extent: {\n      type: Array,\n      validator: arrayLengthValidator(4),\n    },\n    maxResolution: Number,\n    minResolution: Number,\n    /**\n     * @default 28\n     */\n    maxZoom: {\n      type: Number,\n      default: MAX_ZOOM,\n    },\n    /**\n     * @default 0\n     */\n    minZoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @type {string}\n     * @default EPSG:3857\n     */\n    projection: {\n      type: String,\n      default: EPSG_3857,\n    },\n    resolution: Number,\n    resolutions: Array,\n    /**\n     * The initial rotation for the view in **radians** (positive rotation clockwise).\n     * @type {number}\n     * @vueSync\n     */\n    rotation: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n     * @type {number}\n     * @default 0\n     * @vueSync\n     */\n    zoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @default 2\n     */\n    zoomFactor: {\n      type: Number,\n      default: ZOOM_FACTOR,\n    },\n  },\n  computed: {\n    currentZoom () {\n      if (this.rev && this.$view) {\n        return this.$view.getZoom()\n      }\n\n      return this.zoom\n    },\n    currentRotation () {\n      if (this.rev && this.$view) {\n        return this.$view.getRotation()\n      }\n\n      return this.rotation\n    },\n    currentResolution () {\n      if (this.rev && this.$view) {\n        return this.$view.getResolution()\n      }\n\n      return this.resolution\n    },\n    currentCenter () {\n      if (this.rev && this.$view) {\n        return this.pointToDataProj(this.$view.getCenter())\n      }\n    },\n    currentCenterViewProj () {\n      if (this.rev && this.$view) {\n        return this.$view.getCenter()\n      }\n    },\n    /**\n     * @return {ProjectionLike}\n     */\n    resolvedDataProjection () {\n      // exclude this.projection from lookup to allow view rendering in projection\n      // that differs from data projection\n      return coalesce(\n        this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n        this.$options.dataProjection,\n        this.viewProjection,\n      )\n    },\n  },\n  methods: {\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n     * @param {...(AnimationOptions|function(boolean))} args\n     * @return {Promise} Resolves when animation completes\n     */\n    animate (...args) {\n      hasView(this)\n\n      let cb = noop\n      if (isFunction(args[args.length - 1])) {\n        cb = args[args.length - 1]\n        args = args.slice(0, args.length - 1)\n      }\n      args.forEach(opts => {\n        if (!Array.isArray(opts.center)) return\n        opts.center = this.pointToViewProj(opts.center)\n      })\n\n      return new Promise(\n        resolve => this.$view.animate(...args, complete => {\n          cb(complete)\n          resolve(complete)\n        }),\n      )\n    },\n    /**\n     * @return {ol/View~View}\n     * @protected\n     */\n    createOlObject () {\n      return new View({\n        center: this.pointToViewProj(this.center),\n        constrainRotation: this.constrainRotation,\n        enableRotation: this.enableRotation,\n        extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n        maxResolution: this.maxResolution,\n        minResolution: this.minResolution,\n        maxZoom: this.maxZoom,\n        minZoom: this.minZoom,\n        projection: this.projection,\n        resolution: this.resolution,\n        resolutions: this.resolutions,\n        rotation: this.rotation,\n        zoom: this.zoom,\n        zoomFactor: this.zoomFactor,\n      })\n    },\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n     * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n     * @param {FitOptions} [options]\n     * @return {Promise} Resolves when view changes\n     */\n    fit (geometryOrExtent, options = {}) {\n      hasView(this)\n\n      // transform from GeoJSON, vl-feature to ol.Feature\n      if (isPlainObject(geometryOrExtent)) {\n        geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n      } else if (geometryOrExtent instanceof Vue) {\n        geometryOrExtent = geometryOrExtent.$geometry\n      }\n\n      let cb = options.callback || noop\n\n      return new Promise(resolve => {\n        this.$view.fit(geometryOrExtent, {\n          ...options,\n          callback: complete => {\n            cb(complete)\n            resolve(complete)\n          },\n        })\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$viewContainer && this.$viewContainer.setView(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$viewContainer && this.$viewContainer.setView(undefined)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n  },\n  watch: {\n    center (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      value = this.pointToViewProj(value)\n      if (!isEqual(value, this.currentCenterViewProj)) {\n        this.$view.setCenter(value)\n      }\n    },\n    resolution (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentResolution) {\n        this.$view.setResolution(value)\n      }\n    },\n    zoom (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentZoom) {\n        this.$view.setZoom(value)\n      }\n    },\n    rotation (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentRotation) {\n        this.$view.setRotation(value)\n      }\n    },\n    minZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMinZoom()) {\n        this.$view.setMinZoom(value)\n      }\n    },\n    maxZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMaxZoom()) {\n        this.$view.setMaxZoom(value)\n      }\n    },\n    ...makeWatchers([\n      'resolvedDataProjection',\n      'constrainRotation',\n      'enableRotation',\n      'extent',\n      'maxResolution',\n      'minResolution',\n      'projection',\n      'resolutions',\n      'zoomFactor',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n  stubVNode: {\n    empty () {\n      return this.$options.name\n    },\n  },\n  created () {\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * @type {ol/View~View|undefined}\n     */\n    $view: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    $viewContainer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.viewContainer,\n    },\n  })\n}\n\n/**\n * Subscribe to OpenLayers significant events\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasView(this)\n\n  const ft = 1000 / 60\n  const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n  const zoom = resolution.pipe(\n    mapObs(() => ({\n      prop: 'zoom',\n      value: this.$view.getZoom(),\n    })),\n    distinctUntilKeyChanged('value'),\n  )\n\n  const changes = mergeObs(\n    observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n    observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n    resolution,\n    zoom,\n  )\n\n  this.subscribeTo(changes, ({ prop, value }) => {\n    ++this.rev\n    this.$emit(`update:${prop}`, value)\n  })\n}\n","<template>\n  <i :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :center=\"currentCenter\" :zoom=\"currentZoom\" :resolution=\"currentResolution\" :rotation=\"currentRotation\"/>\n  </i>\n</template>\n\n<script>\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, projTransforms } from '../../mixin'\n  import { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\n  import { observableFromOlChangeEvent } from '../../rx-ext'\n  import { hasView } from '../../util/assert'\n  import { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n   * **resolution**, and **rotation** of the map.\n   */\n  export default {\n    name: 'vl-view',\n    mixins: [olCmp, projTransforms],\n    props: {\n      /**\n       * The center coordinate in the view projection.\n       * @type {number[]}\n       * @default [0, 0]\n       */\n      center: {\n        type: Array,\n        default: () => [0, 0],\n        validator: arrayLengthValidator(2),\n      },\n      constrainRotation: {\n        type: [Boolean, Number],\n        default: true,\n      },\n      enableRotation: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * The extent that constrains the center defined in the view projection,\n       * in other words, center cannot be set outside this extent.\n       * @default undefined\n       */\n      extent: {\n        type: Array,\n        validator: arrayLengthValidator(4),\n      },\n      maxResolution: Number,\n      minResolution: Number,\n      /**\n       * @default 28\n       */\n      maxZoom: {\n        type: Number,\n        default: MAX_ZOOM,\n      },\n      /**\n       * @default 0\n       */\n      minZoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @type {string}\n       * @default EPSG:3857\n       */\n      projection: {\n        type: String,\n        default: EPSG_3857,\n      },\n      resolution: Number,\n      resolutions: Array,\n      /**\n       * The initial rotation for the view in **radians** (positive rotation clockwise).\n       * @type {number}\n       * @vueSync\n       */\n      rotation: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n       * @type {number}\n       * @default 0\n       * @vueSync\n       */\n      zoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @default 2\n       */\n      zoomFactor: {\n        type: Number,\n        default: ZOOM_FACTOR,\n      },\n    },\n    computed: {\n      currentZoom () {\n        if (this.rev && this.$view) {\n          return this.$view.getZoom()\n        }\n\n        return this.zoom\n      },\n      currentRotation () {\n        if (this.rev && this.$view) {\n          return this.$view.getRotation()\n        }\n\n        return this.rotation\n      },\n      currentResolution () {\n        if (this.rev && this.$view) {\n          return this.$view.getResolution()\n        }\n\n        return this.resolution\n      },\n      currentCenter () {\n        if (this.rev && this.$view) {\n          return this.pointToDataProj(this.$view.getCenter())\n        }\n      },\n      currentCenterViewProj () {\n        if (this.rev && this.$view) {\n          return this.$view.getCenter()\n        }\n      },\n      /**\n       * @return {ProjectionLike}\n       */\n      resolvedDataProjection () {\n        // exclude this.projection from lookup to allow view rendering in projection\n        // that differs from data projection\n        return coalesce(\n          this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n          this.$options.dataProjection,\n          this.viewProjection,\n        )\n      },\n    },\n    methods: {\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n       * @param {...(AnimationOptions|function(boolean))} args\n       * @return {Promise} Resolves when animation completes\n       */\n      animate (...args) {\n        hasView(this)\n\n        let cb = noop\n        if (isFunction(args[args.length - 1])) {\n          cb = args[args.length - 1]\n          args = args.slice(0, args.length - 1)\n        }\n        args.forEach(opts => {\n          if (!Array.isArray(opts.center)) return\n          opts.center = this.pointToViewProj(opts.center)\n        })\n\n        return new Promise(\n          resolve => this.$view.animate(...args, complete => {\n            cb(complete)\n            resolve(complete)\n          }),\n        )\n      },\n      /**\n       * @return {ol/View~View}\n       * @protected\n       */\n      createOlObject () {\n        return new View({\n          center: this.pointToViewProj(this.center),\n          constrainRotation: this.constrainRotation,\n          enableRotation: this.enableRotation,\n          extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n          maxResolution: this.maxResolution,\n          minResolution: this.minResolution,\n          maxZoom: this.maxZoom,\n          minZoom: this.minZoom,\n          projection: this.projection,\n          resolution: this.resolution,\n          resolutions: this.resolutions,\n          rotation: this.rotation,\n          zoom: this.zoom,\n          zoomFactor: this.zoomFactor,\n        })\n      },\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n       * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n       * @param {FitOptions} [options]\n       * @return {Promise} Resolves when view changes\n       */\n      fit (geometryOrExtent, options = {}) {\n        hasView(this)\n\n        // transform from GeoJSON, vl-feature to ol.Feature\n        if (isPlainObject(geometryOrExtent)) {\n          geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n        } else if (geometryOrExtent instanceof Vue) {\n          geometryOrExtent = geometryOrExtent.$geometry\n        }\n\n        let cb = options.callback || noop\n\n        return new Promise(resolve => {\n          this.$view.fit(geometryOrExtent, {\n            ...options,\n            callback: complete => {\n              cb(complete)\n              resolve(complete)\n            },\n          })\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$viewContainer && this.$viewContainer.setView(this)\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unsubscribeAll()\n        this.$viewContainer && this.$viewContainer.setView(undefined)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n    },\n    watch: {\n      center (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        value = this.pointToViewProj(value)\n        if (!isEqual(value, this.currentCenterViewProj)) {\n          this.$view.setCenter(value)\n        }\n      },\n      resolution (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentResolution) {\n          this.$view.setResolution(value)\n        }\n      },\n      zoom (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentZoom) {\n          this.$view.setZoom(value)\n        }\n      },\n      rotation (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentRotation) {\n          this.$view.setRotation(value)\n        }\n      },\n      minZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMinZoom()) {\n          this.$view.setMinZoom(value)\n        }\n      },\n      maxZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMaxZoom()) {\n          this.$view.setMaxZoom(value)\n        }\n      },\n      ...makeWatchers([\n        'resolvedDataProjection',\n        'constrainRotation',\n        'enableRotation',\n        'extent',\n        'maxResolution',\n        'minResolution',\n        'projection',\n        'resolutions',\n        'zoomFactor',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n    stubVNode: {\n      empty () {\n        return this.$options.name\n      },\n    },\n    created () {\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * @type {ol/View~View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $viewContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.viewContainer,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OpenLayers significant events\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasView(this)\n\n    const ft = 1000 / 60\n    const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n    const zoom = resolution.pipe(\n      mapObs(() => ({\n        prop: 'zoom',\n        value: this.$view.getZoom(),\n      })),\n      distinctUntilKeyChanged('value'),\n    )\n\n    const changes = mergeObs(\n      observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n      observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n      resolution,\n      zoom,\n    )\n\n    this.subscribeTo(changes, ({ prop, value }) => {\n      ++this.rev\n      this.$emit(`update:${prop}`, value)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Map from './map.vue'\nimport View from './view.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Map, options)\n  Object.assign(View, options)\n\n  Vue.component(Map.name, Map)\n  Vue.component(View.name, View)\n}\n\nexport default plugin\n\nexport {\n  Map,\n  View,\n  plugin as install,\n}\n"],"names":["name","mixins","olCmp","layersContainer","interactionsContainer","overlaysContainer","featuresContainer","projTransforms","props","defaultControls","type","Object","Boolean","default","defaultInteractions","keyboardEventTarget","String","Element","Document","loadTilesWhileAnimating","loadTilesWhileInteracting","moveTolerance","Number","pixelRatio","window","devicePixelRatio","maxTilesLoading","tabindex","dataProjection","wrapX","methods","createOlObject","map","Map","controls","_controlsCollection","interactions","_interactionsCollection","layers","_layersCollection","overlays","_overlaysCollection","view","_view","setMapDataProjection","_featuresOverlay","setMap","getCoordinateFromPixel","pixel","hasMap","coordinate","$map","pointToDataProj","getPixelFromCoordinate","pointToViewProj","focus","$el","forEachFeatureAtPixel","callback","opts","forEachLayerAtPixel","getFeaturesAtPixel","refresh","updateSize","render","then","Promise","resolve","once","setView","Vue","$view","View","getView","mount","setTarget","$nextTick","subscribeAll","unmount","clearFeatures","clearLayers","clearInteractions","clearOverlays","unsubscribeAll","subscribeToEvents","getServices","vm","mergeDescriptors","viewContainer","watch","makeWatchers","scheduleRecreate","value","clear","undefined","extend","createDefaultControls","getArray","setSource","VectorSource","features","_featuresCollection","scheduleRefresh","created","Collection","createDefaultInteractions","forEach","interaction","initializeInteraction","VectorLayer","source","defineServices","defineProperties","enumerable","get","$olObject","hasView","ft","pointerEvents","mergeObs","observableFromOlEvent","pipe","throttleTime","distinctUntilChanged","a","b","isEqual","mapObs","evt","otherEvents","events","subscribeTo","$emit","center","Array","validator","arrayLengthValidator","constrainRotation","enableRotation","extent","maxResolution","minResolution","maxZoom","MAX_ZOOM","minZoom","MIN_ZOOM","projection","EPSG_3857","resolution","resolutions","rotation","zoom","zoomFactor","ZOOM_FACTOR","computed","currentZoom","rev","getZoom","currentRotation","getRotation","currentResolution","getResolution","currentCenter","getCenter","currentCenterViewProj","resolvedDataProjection","coalesce","$viewContainer","$options","viewProjection","animate","args","cb","noop","isFunction","length","slice","isArray","complete","extentToViewProj","fit","geometryOrExtent","options","isPlainObject","readGeometryInDataProj","$geometry","getAnimating","setCenter","setResolution","setZoom","setRotation","getMinZoom","setMinZoom","getMaxZoom","setMaxZoom","stubVNode","empty","$services","observableFromOlChangeEvent","prop","distinctUntilKeyChanged","changes","plugin","installed","pick","assign","component"],"mappings":"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"}