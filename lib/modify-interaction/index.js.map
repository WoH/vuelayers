{"version":3,"file":"index.js","sources":["src/component/modify-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/modify-interaction/interaction.vue","src/component/modify-interaction/index.js"],"sourcesContent":["\nimport { altKeyOnly, always, primaryAction } from 'ol/events/condition'\nimport ModifyInteraction from 'ol/interaction/Modify'\nimport interaction from '../../mixin/interaction'\nimport stylesContainer from '../../mixin/styles-container'\nimport { createStyle, defaultEditStyle } from '../../ol-ext/style'\nimport { isCollection, isVectorSource } from '../../ol-ext/util'\nimport observableFromOlEvent from '../../rx-ext/from-ol-event'\nimport { assert, hasInteraction } from '../../util/assert'\nimport { mapValues } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * @vueProto\n * @alias module:modify-interaction/interaction\n * @title vl-interaction-modify\n */\nexport default {\n  name: 'vl-interaction-modify',\n  mixins: [interaction, stylesContainer],\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n  props: {\n    /**\n     * Source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be\n     * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: primaryAction,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.\n     * @type {function|undefined}\n     */\n    deleteCondition: {\n      type: Function,\n      default: altKeyOnly,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added\n     * to the sketch features. Default is `ol.events.condition.always`.\n     * @type {function|undefined}\n     */\n    insertVertexCondition: {\n      type: Function,\n      default: always,\n    },\n    /**\n     * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.\n     * @type {number}\n     */\n    pixelTolerance: {\n      type: Number,\n      default: 10,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  methods: {\n    /**\n     * @return {Promise<Modify>}\n     * @protected\n     */\n    async createInteraction () {\n      let sourceIdent = this.makeIdent(this.source)\n      let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n      assert(isVectorSource(source), `Source \"${sourceIdent}\" doesn't exists in the identity map.`)\n      assert(isCollection(source.getFeaturesCollection()),\n        `Source \"${sourceIdent}\" doesn't provide features collection.`)\n\n      return new ModifyInteraction({\n        features: source.getFeaturesCollection(),\n        deleteCondition: this.deleteCondition,\n        insertVertexCondition: this.insertVertexCondition,\n        pixelTolerance: this.pixelTolerance,\n        style: this.createStyleFunc(),\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRecreate()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::interaction.methods.subscribeAll()\n      this::subscribeToInteractionChanges()\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'source',\n      'condition',\n      'deleteCondition',\n      'insertVertexCondition',\n      'pixelTolerance',\n      'wrapX',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n}\n\n/**\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const modifyEvents = observableFromOlEvent(this.$interaction, ['modifystart', 'modifyend'])\n  this.subscribeTo(modifyEvents, evt => {\n    ++this.rev\n    this.$emit(evt.type, evt)\n  })\n}\n","<script>\n  import { altKeyOnly, always, primaryAction } from 'ol/events/condition'\n  import ModifyInteraction from 'ol/interaction/Modify'\n  import interaction from '../../mixin/interaction'\n  import stylesContainer from '../../mixin/styles-container'\n  import { createStyle, defaultEditStyle } from '../../ol-ext/style'\n  import { isCollection, isVectorSource } from '../../ol-ext/util'\n  import observableFromOlEvent from '../../rx-ext/from-ol-event'\n  import { assert, hasInteraction } from '../../util/assert'\n  import { mapValues } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * @vueProto\n   * @alias module:modify-interaction/interaction\n   * @title vl-interaction-modify\n   */\n  export default {\n    name: 'vl-interaction-modify',\n    mixins: [interaction, stylesContainer],\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n    props: {\n      /**\n       * Source or collection identifier from IdentityMap.\n       * @type {String}\n       */\n      source: {\n        type: String,\n        required: true,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be\n       * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.\n       * @type {function|undefined}\n       */\n      condition: {\n        type: Function,\n        default: primaryAction,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n       * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.\n       * @type {function|undefined}\n       */\n      deleteCondition: {\n        type: Function,\n        default: altKeyOnly,\n      },\n      /**\n       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added\n       * to the sketch features. Default is `ol.events.condition.always`.\n       * @type {function|undefined}\n       */\n      insertVertexCondition: {\n        type: Function,\n        default: always,\n      },\n      /**\n       * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.\n       * @type {number}\n       */\n      pixelTolerance: {\n        type: Number,\n        default: 10,\n      },\n      /**\n       * Wrap the world horizontally on the sketch overlay.\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: false,\n      },\n    },\n    methods: {\n      /**\n       * @return {Promise<Modify>}\n       * @protected\n       */\n      async createInteraction () {\n        let sourceIdent = this.makeIdent(this.source)\n        let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n        assert(isVectorSource(source), `Source \"${sourceIdent}\" doesn't exists in the identity map.`)\n        assert(isCollection(source.getFeaturesCollection()),\n          `Source \"${sourceIdent}\" doesn't provide features collection.`)\n\n        return new ModifyInteraction({\n          features: source.getFeaturesCollection(),\n          deleteCondition: this.deleteCondition,\n          insertVertexCondition: this.insertVertexCondition,\n          pixelTolerance: this.pixelTolerance,\n          style: this.createStyleFunc(),\n          wrapX: this.wrapX,\n        })\n      },\n      /**\n       * @return {function(feature: Feature): Style}\n       * @protected\n       */\n      getDefaultStyles () {\n        const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n        return function __selectDefaultStyleFunc (feature) {\n          if (feature.getGeometry()) {\n            return defaultStyles[feature.getGeometry().getType()]\n          }\n        }\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        return mergeDescriptors(\n          this::interaction.methods.getServices(),\n          this::stylesContainer.methods.getServices(),\n        )\n      },\n      /**\n       * @return {Interaction|undefined}\n       * @protected\n       */\n      getStyleTarget () {\n        return this.$interaction\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this::interaction.methods.mount()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this::interaction.methods.unmount()\n      },\n      /**\n       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n       * @return {void}\n       * @protected\n       */\n      setStyle (styles) {\n        if (styles !== this._styles) {\n          this._styles = styles\n          this.scheduleRecreate()\n        }\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::interaction.methods.subscribeAll()\n        this::subscribeToInteractionChanges()\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'source',\n        'condition',\n        'deleteCondition',\n        'insertVertexCondition',\n        'pixelTolerance',\n        'wrapX',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n  }\n\n  /**\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const modifyEvents = observableFromOlEvent(this.$interaction, ['modifystart', 'modifyend'])\n    this.subscribeTo(modifyEvents, evt => {\n      ++this.rev\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["name","mixins","interaction","stylesContainer","stubVNode","empty","attrs","class","$options","props","source","type","String","required","condition","Function","default","primaryAction","deleteCondition","altKeyOnly","insertVertexCondition","always","pixelTolerance","Number","wrapX","Boolean","methods","createInteraction","sourceIdent","makeIdent","$identityMap","get","INSTANCE_PROMISE_POOL","assert","isVectorSource","isCollection","getFeaturesCollection","ModifyInteraction","features","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","map","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRecreate","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","hasInteraction","modifyEvents","observableFromOlEvent","subscribeTo","evt","rev","$emit","plugin","Vue","options","installed","pick","Object","assign","Interaction","component"],"mappings":"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"}